---
phase: 04-core-content-generation
plan: 06
type: execute
wave: 3
depends_on: ["04-02", "04-03", "04-04", "04-05"]
files_modified:
  - src/api/content.py
  - tests/test_content_api.py
  - app.py
autonomous: true

must_haves:
  truths:
    - "User can generate content for any activity via POST /api/courses/<id>/activities/<aid>/generate"
    - "User can regenerate content with different parameters, preserving previous version"
    - "User can edit generated content inline via PUT /api/courses/<id>/activities/<aid>/content"
    - "Generated content is stored in Activity.content with metadata (word_count, duration)"
  artifacts:
    - path: "src/api/content.py"
      provides: "Content generation API Blueprint with generate, regenerate, edit endpoints"
      contains: "content_bp = Blueprint"
    - path: "tests/test_content_api.py"
      provides: "API integration tests with mocked generators"
      contains: "def test_"
  key_links:
    - from: "src/api/content.py"
      to: "src/generators/video_script_generator.py"
      via: "imports and calls VideoScriptGenerator"
      pattern: "from src.generators.video_script_generator import"
    - from: "src/api/content.py"
      to: "src/generators/reading_generator.py"
      via: "imports and calls ReadingGenerator"
      pattern: "from src.generators.reading_generator import"
    - from: "src/api/content.py"
      to: "src/generators/quiz_generator.py"
      via: "imports and calls QuizGenerator"
      pattern: "from src.generators.quiz_generator import"
    - from: "src/api/content.py"
      to: "src/generators/rubric_generator.py"
      via: "imports and calls RubricGenerator"
      pattern: "from src.generators.rubric_generator import"
    - from: "app.py"
      to: "src/api/content.py"
      via: "registers content_bp Blueprint"
      pattern: "init_content_bp"
---

<objective>
Create the content generation API endpoints that allow users to generate, regenerate, and edit content for any activity via REST API.

Purpose: Wire the 4 generators into the Flask API so users can trigger content generation and manage the generate-edit-approve workflow.
Output: Content API Blueprint with endpoints, registered in app.py, with integration tests.
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/04-core-content-generation/04-RESEARCH.md
@.planning/phases/04-core-content-generation/04-01-SUMMARY.md
@src/api/blueprint.py
@src/core/models.py
@app.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create content generation API Blueprint</name>
  <files>
    src/api/content.py
    app.py
  </files>
  <action>
Create `src/api/content.py` as a Flask Blueprint following the exact pattern from `src/api/blueprint.py`:

```python
content_bp = Blueprint('content', __name__)
_project_store = None

def init_content_bp(project_store):
    global _project_store
    _project_store = project_store
```

Endpoints:

**POST /api/courses/<course_id>/activities/<activity_id>/generate**
- Request JSON: `{"learning_objective": "...", "topic": "...", "audience_level": "intermediate", ...}` (additional params vary by content_type)
- Logic:
  1. Load course, find activity using `_find_activity()` helper (same pattern as activities.py)
  2. Check activity.build_state is DRAFT or GENERATED (can regenerate GENERATED, not GENERATING)
  3. Determine generator from activity.content_type:
     - ContentType.VIDEO -> VideoScriptGenerator
     - ContentType.READING -> ReadingGenerator
     - ContentType.QUIZ -> QuizGenerator
     - ContentType.RUBRIC -> RubricGenerator
     - Other -> return 400 "Unsupported content type for generation"
  4. Set activity.build_state = BuildState.GENERATING
  5. Save course (persist GENERATING state)
  6. Call generator.generate(schema, **params)
  7. Store result: activity.content = content.model_dump_json() (JSON string), activity.word_count = metadata["word_count"], activity.estimated_duration_minutes = metadata["estimated_duration_minutes"]
  8. Set activity.build_state = BuildState.GENERATED
  9. Save course
  10. Return 200 with {"content": content.model_dump(), "metadata": metadata, "build_state": "generated"}
- Error handling:
  - 404 if course or activity not found
  - 400 if content_type not supported
  - 409 if build_state is GENERATING (generation in progress)
  - 502 if AI API error (catch anthropic.APIError)

**POST /api/courses/<course_id>/activities/<activity_id>/regenerate**
- Same as generate but:
  1. Only allowed if build_state is GENERATED or REVIEWED (has existing content)
  2. Before generating, store previous content in activity.metadata["previous_content"] and previous word_count in activity.metadata["previous_word_count"]
  3. Accept optional "feedback" field in request for regeneration guidance (passed as extra context to generator)
  4. Return 200 with same format as generate

**PUT /api/courses/<course_id>/activities/<activity_id>/content**
- Request JSON: `{"content": "...", "build_state": "reviewed"}` (content is JSON string or plain text)
- Logic:
  1. Load course, find activity
  2. Update activity.content with provided content
  3. Recalculate word_count using ContentMetadata.count_words()
  4. Optionally update build_state if provided (must be valid BuildState)
  5. Save and return updated activity
- This supports GEN-13 (inline editing before approving)

Helper function `_find_activity(course, activity_id)` -> (module, lesson, activity) or None:
- Traverse course.modules -> lessons -> activities to find by ID
- Same pattern as `src/api/activities.py` _find_activity helper

Register in `app.py`: Import init_content_bp, call it with project_store, register content_bp. Follow exact pattern of blueprint_bp registration.
  </action>
  <verify>Run `python -c "from src.api.content import content_bp, init_content_bp; print('Content API importable')"` to verify import works.</verify>
  <done>Content API Blueprint created with generate, regenerate, and edit endpoints. Registered in app.py.</done>
</task>

<task type="auto">
  <name>Task 2: Create content API integration tests</name>
  <files>
    tests/test_content_api.py
  </files>
  <action>
Create `tests/test_content_api.py` with integration tests. Use the `client` fixture from conftest.py and mock the generator classes.

Test helper: Create a course with a module, lesson, and activity (content_type=VIDEO, build_state=DRAFT) before each test that needs it. Use the existing API endpoints:
```python
# Create course via API
resp = client.post('/api/courses', json={"title": "Test Course", ...})
course_id = resp.get_json()["id"]
# Create module
resp = client.post(f'/api/courses/{course_id}/modules', json={"title": "Module 1"})
module_id = resp.get_json()["id"]
# Create lesson
resp = client.post(f'/api/courses/{course_id}/modules/{module_id}/lessons', json={"title": "Lesson 1"})
lesson_id = resp.get_json()["id"]
# Create activity
resp = client.post(f'/api/courses/{course_id}/lessons/{lesson_id}/activities', json={"title": "Video 1", "content_type": "video", "activity_type": "video_lecture"})
activity_id = resp.get_json()["id"]
```

Mock generators at the module level: `mocker.patch("src.api.content.VideoScriptGenerator")` etc.

Tests:
1. test_generate_video_content - POST generate for VIDEO activity, mock VideoScriptGenerator, verify 200 with content and metadata
2. test_generate_reading_content - POST generate for READING activity, mock ReadingGenerator, verify 200
3. test_generate_quiz_content - POST generate for QUIZ activity, mock QuizGenerator, verify 200
4. test_generate_rubric_content - POST generate for RUBRIC activity, mock RubricGenerator, verify 200
5. test_generate_unsupported_content_type - Create HOL activity, POST generate, verify 400
6. test_generate_sets_build_state - After generate, verify activity build_state is "generated"
7. test_generate_conflict_when_generating - Set activity build_state to GENERATING, POST generate, verify 409
8. test_regenerate_preserves_previous - Generate content, then regenerate, verify metadata["previous_content"] preserved
9. test_regenerate_requires_existing_content - POST regenerate on DRAFT activity, verify 400
10. test_edit_content_inline - PUT content endpoint with new content string, verify updated
11. test_edit_content_recalculates_word_count - PUT content with known word count, verify word_count updated
12. test_generate_404_course_not_found - POST generate with bad course_id, verify 404
13. test_generate_404_activity_not_found - POST generate with bad activity_id, verify 404

Each mock should return a tuple of (MockPydanticModel, metadata_dict) from the generate() method. The MockPydanticModel needs model_dump() and model_dump_json() methods.
  </action>
  <verify>Run `python -m pytest tests/test_content_api.py -v` and confirm all 13 tests pass.</verify>
  <done>13 content API tests passing, covering generate/regenerate/edit for all 4 content types, error cases, and build state tracking.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_content_api.py -v` - All 13 tests pass
2. `python -m pytest tests/ -v` - No regressions in existing 180+ tests
3. Manual check: `python -c "from app import app; print([r.rule for r in app.url_map.iter_rules() if 'content' in r.rule or 'generate' in r.rule])"` - Verify endpoints registered
</verification>

<success_criteria>
- Content API Blueprint registered in app.py with generate, regenerate, edit endpoints
- 13+ integration tests passing with mocked generators
- Generate endpoint dispatches to correct generator based on content_type
- Regenerate preserves previous content in metadata
- Edit endpoint recalculates word_count
- Build state transitions: DRAFT -> GENERATING -> GENERATED
- Proper error handling (404, 400, 409, 502)
- No regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-content-generation/04-06-SUMMARY.md`
</output>
