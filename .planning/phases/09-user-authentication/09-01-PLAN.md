---
phase: 09-user-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/auth/__init__.py
  - src/auth/models.py
  - src/auth/db.py
  - instance/schema.sql
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "User model exists with email, password_hash, name fields"
    - "Passwords are hashed using Werkzeug scrypt (never stored plain text)"
    - "SQLite database created in instance/users.db"
    - "User can be created and retrieved from database"
  artifacts:
    - path: "src/auth/models.py"
      provides: "User class with UserMixin and password methods"
      exports: ["User"]
    - path: "src/auth/db.py"
      provides: "SQLite connection management with Flask g object"
      exports: ["get_db", "close_db", "init_db", "init_app"]
    - path: "instance/schema.sql"
      provides: "SQL schema for user table"
      contains: "CREATE TABLE user"
  key_links:
    - from: "src/auth/models.py"
      to: "src/auth/db.py"
      via: "get_db() for database operations"
      pattern: "from src.auth.db import get_db"
---

<objective>
Create the User model with Flask-Login's UserMixin, SQLite database infrastructure, and password hashing utilities.

Purpose: Establishes the foundation for all authentication features. User data needs ACID compliance (unlike course data which is document-shaped), so SQLite is the right choice.

Output:
- `src/auth/` package with User model and database utilities
- SQLite schema for user table
- Password hashing via Werkzeug (already installed)
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-user-authentication/09-RESEARCH.md

# Existing patterns
@src/config.py
@src/core/project_store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth package with User model</name>
  <files>src/auth/__init__.py, src/auth/models.py</files>
  <action>
Create `src/auth/__init__.py` with exports for User, get_db, init_db, init_app.

Create `src/auth/models.py` with User class:
- Inherit from flask_login.UserMixin
- Fields: id (int), email (str), password_hash (str), name (Optional[str]), created_at (str)
- `set_password(password)`: Use `werkzeug.security.generate_password_hash(password)` to hash
- `check_password(password)`: Use `werkzeug.security.check_password_hash()` to verify
- `get_id()`: Return str(self.id) for Flask-Login compatibility
- `to_dict()`: Return dict with id, email, name, created_at (exclude password_hash for security)
- Class methods:
  - `get_by_id(user_id)`: Load user from database by ID
  - `get_by_email(email)`: Load user from database by email
  - `create(email, password, name=None)`: Create new user with hashed password

DO NOT use SQLAlchemy. Use raw SQLite queries for simplicity (as shown in research).
  </action>
  <verify>
`python -c "from src.auth.models import User; print('User model imported')"` succeeds
  </verify>
  <done>User class exists with password hashing methods using Werkzeug</done>
</task>

<task type="auto">
  <name>Task 2: Create SQLite database infrastructure</name>
  <files>src/auth/db.py, instance/schema.sql</files>
  <action>
Create `instance/schema.sql` with user table:
```sql
CREATE TABLE IF NOT EXISTS user (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    name TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

Create `src/auth/db.py` with Flask-style database utilities:
- `get_db()`: Get database connection from Flask g object; create if not exists; set row_factory to sqlite3.Row
- `close_db(e=None)`: Close database connection if open; register with app.teardown_appcontext
- `init_db()`: Execute schema.sql to create tables
- `init_app(app)`: Register close_db teardown; add `flask init-db` CLI command

Database path: Use app.config['DATABASE'] or default to `instance/users.db`.
Create `instance/` directory if it doesn't exist.
  </action>
  <verify>
`python -c "from src.auth.db import get_db, init_db, init_app; print('DB utilities imported')"` succeeds
  </verify>
  <done>SQLite infrastructure ready with schema.sql and Flask integration utilities</done>
</task>

<task type="auto">
  <name>Task 3: Add Flask-Login and Flask-Mail dependencies</name>
  <files>requirements.txt</files>
  <action>
Add to requirements.txt:
```
Flask-Login>=0.7.0
Flask-Mail>=0.10.0
Flask-Limiter>=4.1.0
```

Run `pip install -r requirements.txt` to install.

Also add to src/config.py:
- SECRET_KEY: os.getenv("SECRET_KEY", "dev-secret-key-change-in-production")
- DATABASE: Path("instance/users.db")

Update .env.example with:
```
SECRET_KEY=your-secret-key-here
```
  </action>
  <verify>
`python -c "import flask_login; import flask_mail; import flask_limiter; print('All auth dependencies installed')"` succeeds
  </verify>
  <done>Flask-Login, Flask-Mail, Flask-Limiter installed and configured</done>
</task>

</tasks>

<verification>
1. All imports work without errors
2. User model has password hashing methods
3. Database schema can be initialized
4. New dependencies are installed
5. `pytest tests/test_auth_models.py -v` passes (create basic tests)
</verification>

<success_criteria>
- User model with UserMixin and password hashing is importable
- SQLite database infrastructure is ready
- Dependencies installed in requirements.txt
- Config updated with SECRET_KEY and DATABASE settings
</success_criteria>

<output>
After completion, create `.planning/phases/09-user-authentication/09-01-SUMMARY.md`
</output>
