---
phase: 03-blueprint-generation
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/api/blueprint.py
  - app.py
  - tests/test_blueprint_api.py
autonomous: true

must_haves:
  truths:
    - "POST /api/courses/<id>/blueprint/generate returns a blueprint proposal with validation results"
    - "POST /api/courses/<id>/blueprint/accept converts blueprint to course structure and saves to disk"
    - "POST /api/courses/<id>/blueprint/refine regenerates blueprint with user feedback"
    - "Blueprint is NOT saved to course until user explicitly accepts"
    - "Validation errors are returned alongside generated blueprint"
  artifacts:
    - path: "src/api/blueprint.py"
      provides: "Blueprint API Flask Blueprint with generate/accept/refine endpoints"
      contains: "blueprint_bp"
    - path: "tests/test_blueprint_api.py"
      provides: "Integration tests for blueprint API endpoints"
      contains: "test_generate_blueprint_endpoint"
  key_links:
    - from: "src/api/blueprint.py"
      to: "src/generators/blueprint_generator.py"
      via: "BlueprintGenerator.generate()"
      pattern: "generator.generate"
    - from: "src/api/blueprint.py"
      to: "src/validators/course_validator.py"
      via: "CourseraValidator.validate()"
      pattern: "validator.validate"
    - from: "src/api/blueprint.py"
      to: "src/generators/blueprint_converter.py"
      via: "blueprint_to_course()"
      pattern: "blueprint_to_course"
    - from: "app.py"
      to: "src/api/blueprint.py"
      via: "Blueprint registration"
      pattern: "register_blueprint.*blueprint_bp"
---

<objective>
Create the Blueprint API Flask Blueprint with generate/accept/refine endpoints, register it in app.py, and write integration tests.

Purpose: This is the user-facing API layer that ties together the generator (Plan 01), validator (Plan 02), and converter (Plan 02) into a review-before-commit workflow. Users generate a blueprint proposal, review it with validation feedback, optionally refine it, and then accept to commit the structure to their course.

Output: `src/api/blueprint.py` (Flask Blueprint with 3 endpoints), updated `app.py` (Blueprint registration), and `tests/test_blueprint_api.py` (integration tests).
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-blueprint-generation/03-01-SUMMARY.md
@.planning/phases/03-blueprint-generation/03-02-SUMMARY.md
@app.py
@src/api/modules.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Blueprint API Flask Blueprint</name>
  <files>src/api/blueprint.py</files>
  <action>
Create `src/api/blueprint.py` following the exact same pattern as `src/api/modules.py` (Flask Blueprint with init_bp function and module-level _project_store):

```python
"""Blueprint generation API endpoints.

Provides endpoints for generating, validating, accepting, and refining
AI-generated course blueprints. Blueprints are generated as proposals
that must be explicitly accepted before modifying the course structure.
"""

from flask import Blueprint, request, jsonify

from src.generators.blueprint_generator import BlueprintGenerator, CourseBlueprint
from src.validators.course_validator import CourseraValidator
from src.generators.blueprint_converter import blueprint_to_course

blueprint_bp = Blueprint('blueprint', __name__)
_project_store = None

def init_blueprint_bp(project_store):
    global _project_store
    _project_store = project_store
```

**Endpoint 1: POST /api/courses/<course_id>/blueprint/generate**

Request JSON:
```json
{
    "description": "Course description (optional, falls back to course.description)",
    "learning_outcomes": ["outcome 1", "outcome 2"],
    "target_duration": 90,
    "audience_level": "intermediate"
}
```

Logic:
1. Load course from store (404 if not found)
2. Check AI is available (check if ANTHROPIC_API_KEY is set via Config; 503 if not)
3. Extract parameters from request JSON, falling back to course fields:
   - description: request data OR course.description
   - learning_outcomes: request data OR format course.learning_outcomes as ["audience behavior condition degree" strings]
   - target_duration: request data OR course.target_duration_minutes
   - audience_level: request data OR course.audience_level
4. Validate that description is not empty (400 error)
5. Validate that learning_outcomes has at least 1 entry (400 error)
6. Create BlueprintGenerator and call generate()
7. Create CourseraValidator and call validate(blueprint, target_duration)
8. Return JSON with blueprint (model_dump), validation results, and status "pending_review"

Handle AI API errors (anthropic exceptions) with try/except returning 502 status with error message.

**Endpoint 2: POST /api/courses/<course_id>/blueprint/accept**

Request JSON:
```json
{
    "blueprint": { ... }
}
```

Logic:
1. Load course from store (404 if not found)
2. Parse blueprint from request JSON (400 if missing)
3. Validate blueprint using CourseBlueprint.model_validate(data) (400 if invalid schema)
4. Run CourseraValidator.validate() - return 422 if validation has errors (is_valid=False)
5. Call blueprint_to_course(blueprint, course) to apply structure
6. Save course via project_store.save()
7. Return JSON with success message, module count, lesson count, activity count

**Endpoint 3: POST /api/courses/<course_id>/blueprint/refine**

Request JSON:
```json
{
    "blueprint": { ... },
    "feedback": "string"
}
```

Logic:
1. Load course from store (404 if not found)
2. Check AI is available (503 if not)
3. Extract blueprint and feedback from request (400 if missing)
4. Create BlueprintGenerator
5. Build a refinement prompt that includes:
   - The previous blueprint as JSON context
   - The user's feedback as refinement instructions
   - Original course description and outcomes
6. Call generator.generate() with an enhanced prompt that includes the previous blueprint + feedback
7. Validate the refined blueprint
8. Return JSON with refined blueprint, validation, and status "pending_review"

**Error handling pattern** (consistent with existing endpoints):
- 400: Bad request (missing/invalid input)
- 404: Course not found
- 422: Validation failed (blueprint has errors)
- 502: AI API error
- 503: AI not available (no API key)
  </action>
  <verify>Run `py -3 -c "from src.api.blueprint import blueprint_bp, init_blueprint_bp; print('Import OK')"` to confirm imports work.</verify>
  <done>Blueprint API Blueprint exists with generate, accept, and refine endpoints. All three endpoints handle errors consistently.</done>
</task>

<task type="auto">
  <name>Task 2: Register Blueprint API in app.py</name>
  <files>app.py</files>
  <action>
Add the blueprint Blueprint registration to app.py, following the exact pattern of the existing Blueprint registrations (modules, lessons, activities, learning_outcomes).

After the learning_outcomes registration block, add:

```python
from src.api.blueprint import blueprint_bp, init_blueprint_bp
init_blueprint_bp(project_store)
app.register_blueprint(blueprint_bp)
```

This is a 3-line addition. Do not modify any other code in app.py.
  </action>
  <verify>Run `py -3 -c "from app import app; print([rule.rule for rule in app.url_map.iter_rules() if 'blueprint' in rule.rule])"` to confirm blueprint routes are registered.</verify>
  <done>Blueprint API routes are registered in the Flask app. The app starts without errors.</done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests for Blueprint API</name>
  <files>tests/test_blueprint_api.py</files>
  <action>
Create `tests/test_blueprint_api.py` with integration tests using Flask test client (same pattern as existing API tests like test_app.py).

**Setup:** Use the `client` fixture from conftest.py. Create helper to set up a course with outcomes.

**Mocking pattern for AI:** Mock `src.api.blueprint.BlueprintGenerator` at the module level where it's used. The mock generator.generate() should return a valid CourseBlueprint Pydantic model built from test data.

**Helper:** Create `SAMPLE_BLUEPRINT` as a CourseBlueprint instance for test reuse:
```python
def make_test_blueprint():
    """Create a valid CourseBlueprint for testing."""
    # 2 modules, 3 lessons each, 2 activities per lesson
    # ~90 min total, realistic types
    return CourseBlueprint(
        modules=[...],
        total_duration_minutes=90.0,
        content_distribution={"video": 0.33, "reading": 0.22, "quiz": 0.22, "hol": 0.22},
        rationale="Test blueprint rationale"
    )
```

**Tests:**

1. `test_generate_blueprint_success(client, mocker)` - Create course, POST to generate with description and outcomes. Mock BlueprintGenerator. Assert 200, response has "blueprint", "validation", "status" keys.

2. `test_generate_blueprint_course_not_found(client)` - POST to generate for nonexistent course. Assert 404.

3. `test_generate_blueprint_missing_description(client, mocker)` - Create course with empty description, POST generate with no description in body and empty course description. Assert 400 error about description.

4. `test_generate_blueprint_no_ai(client, mocker)` - Mock Config.ANTHROPIC_API_KEY to be None/empty. Assert 503.

5. `test_accept_blueprint_success(client, mocker)` - Create course, POST accept with valid blueprint dict. Assert 200, response includes module_count. Verify course now has modules via GET /api/courses/<id>.

6. `test_accept_blueprint_validation_errors(client)` - POST accept with blueprint having 5 modules (invalid). Assert 422.

7. `test_accept_blueprint_missing_data(client)` - POST accept with empty body. Assert 400.

8. `test_accept_blueprint_creates_correct_structure(client, mocker)` - Accept a 2-module blueprint. GET the course and verify module count, lesson count, activity count match the blueprint.

9. `test_refine_blueprint_success(client, mocker)` - Create course, POST refine with previous blueprint and feedback. Mock generator. Assert 200, response has refined blueprint.

10. `test_refine_blueprint_missing_feedback(client)` - POST refine without feedback field. Assert 400.

11. `test_generate_uses_course_defaults(client, mocker)` - Create course with description and outcomes, POST generate with empty body. Assert generator was called with course's description and outcomes.

12. `test_accept_blueprint_preserves_course_id(client, mocker)` - Accept blueprint, verify course ID unchanged.

For mocking the generator in generate/refine tests:
```python
mock_generator_class = mocker.patch('src.api.blueprint.BlueprintGenerator')
mock_instance = mock_generator_class.return_value
mock_instance.generate.return_value = make_test_blueprint()
```

For accept tests, no AI mocking needed - just pass a valid blueprint dict via `.model_dump()`.
  </action>
  <verify>
Run `py -3 -m pytest tests/test_blueprint_api.py -v` and confirm all tests pass.
Run `py -3 -m pytest tests/ -v` and confirm all existing + new tests pass (target: 170+ tests total).
  </verify>
  <done>12+ blueprint API integration tests pass. All existing tests still pass. Total test count 170+.</done>
</task>

</tasks>

<verification>
1. `py -3 -c "from app import app; rules = [r.rule for r in app.url_map.iter_rules() if 'blueprint' in r.rule]; print(rules); assert len(rules) >= 3"` — three blueprint routes registered
2. `py -3 -m pytest tests/test_blueprint_api.py -v` — all 12+ tests pass
3. `py -3 -m pytest tests/ -v` — all tests pass (170+ total, no regressions)
4. Manual check: POST /api/courses/<id>/blueprint/generate returns {blueprint, validation, status}
</verification>

<success_criteria>
- Three API endpoints exist: generate, accept, refine (all under /api/courses/<id>/blueprint/)
- Generate returns blueprint + validation without saving to course
- Accept converts blueprint to course structure and saves (review-before-commit workflow)
- Refine regenerates with user feedback context
- 12+ integration tests pass covering success paths, error paths, and data flow
- All 142+ existing tests still pass
- Blueprint registration in app.py follows established pattern
</success_criteria>

<output>
After completion, create `.planning/phases/03-blueprint-generation/03-03-SUMMARY.md`
</output>
