---
phase: 10-collaboration-roles
plan: 03
type: execute
wave: 2
depends_on: ["10-01", "10-02"]
files_modified:
  - src/collab/decorators.py
  - src/collab/__init__.py
  - tests/test_permission_decorator.py
autonomous: true

must_haves:
  truths:
    - "require_permission decorator blocks access without required permission"
    - "Permission checks happen on every API request (not cached)"
    - "Course owner is automatically made collaborator when creating course"
    - "Decorator extracts course_id from route parameters"
  artifacts:
    - path: "src/collab/decorators.py"
      provides: "require_permission decorator for API routes"
      exports: ["require_permission", "ensure_owner_collaborator"]
  key_links:
    - from: "src/collab/decorators.py"
      to: "src/collab/permissions.py"
      via: "has_permission check"
      pattern: "from src.collab.permissions import has_permission"
---

<objective>
Create the permission enforcement decorator for API routes.

Purpose: Protect all course-related API endpoints with permission checks that query fresh on each request
Output: Decorator that checks user permissions on specific courses and utility for course owner setup
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-collaboration-roles/10-CONTEXT.md
@.planning/phases/10-collaboration-roles/10-RESEARCH.md
@.planning/phases/10-collaboration-roles/10-01-SUMMARY.md
@src/collab/permissions.py
@src/collab/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create permission enforcement decorator</name>
  <files>src/collab/decorators.py, src/collab/__init__.py</files>
  <action>
Create src/collab/decorators.py with:

1. require_permission(permission_code) decorator:
   - Uses functools.wraps to preserve function metadata
   - Extracts course_id from:
     - kwargs.get('course_id') first
     - Then request.view_args.get('course_id')
     - Returns 400 if course_id not found
   - Gets current user from flask_login.current_user
   - Calls has_permission(current_user.id, course_id, permission_code)
   - Returns 403 JSON error if permission denied: {"error": "Permission denied"}
   - Calls wrapped function if permitted

2. require_any_permission(*permission_codes) decorator:
   - Same as require_permission but passes if ANY of the codes match
   - Useful for endpoints that accept multiple permission levels

3. require_collaborator() decorator:
   - Simpler check: just verifies user is a collaborator on the course
   - Does not check specific permission
   - Useful for read-only endpoints that any collaborator can access

Usage example:
```python
@app.route('/api/courses/<course_id>/content', methods=['POST'])
@login_required
@require_permission('edit_content')
def update_content(course_id):
    # User has edit_content permission on this course
    pass
```

Note: @login_required must come before @require_permission since we need current_user.

Update src/collab/__init__.py to export require_permission, require_any_permission, require_collaborator.
  </action>
  <verify>python -c "from src.collab.decorators import require_permission; print('Decorator loaded')"</verify>
  <done>Permission decorator that enforces access control on API routes</done>
</task>

<task type="auto">
  <name>Task 2: Create owner-collaborator utility</name>
  <files>src/collab/decorators.py</files>
  <action>
Add utility function to ensure course creator becomes owner:

1. ensure_owner_collaborator(course_id, user_id) function:
   - Check if user is already a collaborator on course
   - If not, create Owner role for course (from template)
   - Create collaborator entry linking user to course as Owner
   - Return the Collaborator instance

2. Purpose: Called when a user creates a new course to automatically make them the owner.

This function will be used in app.py when POST /api/courses creates a new course.

Implementation:
```python
def ensure_owner_collaborator(course_id, user_id):
    """Ensure user is owner of course. Creates Owner role and collaborator if needed.

    Args:
        course_id: The course identifier
        user_id: The user who should be owner

    Returns:
        Collaborator instance
    """
    from src.collab.models import Collaborator, Role

    # Check if already collaborator
    existing = Collaborator.get_by_user_and_course(user_id, course_id)
    if existing:
        return existing

    # Create Owner role for this course from template
    owner_role = Role.create_from_template(course_id, "Owner")

    # Make user the owner (invited_by self for initial owner)
    collaborator = Collaborator.create(course_id, user_id, owner_role.id, invited_by=user_id)

    return collaborator
```
  </action>
  <verify>python -c "from src.collab.decorators import ensure_owner_collaborator; print('Utility loaded')"</verify>
  <done>Utility function to make course creators automatic owners</done>
</task>

<task type="auto">
  <name>Task 3: Create permission decorator tests</name>
  <files>tests/test_permission_decorator.py</files>
  <action>
Create tests/test_permission_decorator.py with:

1. Test fixtures:
   - test_app - Flask app with test database
   - test_db - Fresh database for each test
   - test_user - User to test with
   - test_course - Course in database (created via ProjectStore)
   - test_owner_role - Owner role for test_course
   - test_collaborator - User as Owner on test_course

2. Decorator behavior tests:
   - test_require_permission_allows_with_permission - Returns 200 when user has permission
   - test_require_permission_denies_without_permission - Returns 403 JSON error
   - test_require_permission_returns_400_no_course_id - Missing course_id in route
   - test_require_permission_requires_login - Returns 401 when not logged in

3. Multiple permission tests:
   - test_require_any_permission_one_of_many - Passes with any matching permission
   - test_require_any_permission_none_match - Fails when none match

4. Collaborator check tests:
   - test_require_collaborator_allows_any_role - Any collaborator can access
   - test_require_collaborator_denies_non_collaborator - Non-collaborator gets 403

5. Owner utility tests:
   - test_ensure_owner_creates_role_and_collaborator - Fresh course gets Owner setup
   - test_ensure_owner_idempotent - Calling twice returns same collaborator

6. Fresh permission check tests:
   - test_permission_change_takes_effect_immediately - Modify role, next request reflects change
   - test_revoked_collaborator_loses_access - Remove collaborator, next request fails

Create test route helper:
```python
@test_app.route('/test/courses/<course_id>/protected')
@login_required
@require_permission('edit_content')
def protected_route(course_id):
    return jsonify({"status": "ok"})
```
  </action>
  <verify>pytest tests/test_permission_decorator.py -v</verify>
  <done>12+ tests covering decorator behavior, permission checks, and owner setup</done>
</task>

</tasks>

<verification>
1. require_permission decorator returns 403 for unauthorized users
2. require_permission decorator allows authorized users
3. Permission checks query database fresh (no caching)
4. ensure_owner_collaborator creates role and collaborator for new courses
5. ensure_owner_collaborator is idempotent
6. All tests pass
</verification>

<success_criteria>
- [ ] require_permission decorator extracts course_id from route
- [ ] require_permission returns 403 JSON when permission denied
- [ ] require_permission passes through when permission granted
- [ ] require_any_permission accepts any of the listed permissions
- [ ] ensure_owner_collaborator creates Owner role from template
- [ ] ensure_owner_collaborator is idempotent (safe to call multiple times)
- [ ] Permission changes take effect immediately (no stale cache)
- [ ] 12+ tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-collaboration-roles/10-03-SUMMARY.md`
</output>
