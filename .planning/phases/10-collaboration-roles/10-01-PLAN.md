---
phase: 10-collaboration-roles
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - instance/schema.sql
  - src/collab/__init__.py
  - src/collab/models.py
  - src/collab/permissions.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "Permission codes are defined for content, structure, and course operations"
    - "Roles can be created per-course with assigned permissions"
    - "Collaborator relationships link users to courses with specific roles"
    - "4 predefined role templates exist (Owner, Designer, Reviewer, SME)"
  artifacts:
    - path: "src/collab/models.py"
      provides: "Role, Permission, Collaborator models with database operations"
      min_lines: 150
    - path: "src/collab/permissions.py"
      provides: "Permission definitions and helper functions"
      exports: ["PERMISSIONS", "ROLE_TEMPLATES", "has_permission", "get_user_permissions"]
    - path: "instance/schema.sql"
      provides: "course_role, permission, role_permission, collaborator tables"
      contains: "CREATE TABLE course_role"
  key_links:
    - from: "src/collab/permissions.py"
      to: "src/auth/db.py"
      via: "get_db for permission queries"
      pattern: "from src.auth.db import get_db"
---

<objective>
Create the collaboration data models and permission infrastructure for role-based access control.

Purpose: Establish the foundation for multi-user course collaboration with granular permissions
Output: Database schema, Python models, and permission utilities for roles and collaborators
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-collaboration-roles/10-CONTEXT.md
@.planning/phases/10-collaboration-roles/10-RESEARCH.md
@src/auth/db.py
@src/auth/models.py
@instance/schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend database schema for collaboration</name>
  <files>instance/schema.sql</files>
  <action>
Add collaboration tables to schema.sql after the existing user table:

1. `course_role` table - Custom roles per course:
   - id INTEGER PRIMARY KEY AUTOINCREMENT
   - course_id TEXT NOT NULL
   - name TEXT NOT NULL (e.g., "Designer", "Reviewer")
   - created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   - UNIQUE(course_id, name)

2. `permission` table - Granular permission definitions:
   - id INTEGER PRIMARY KEY AUTOINCREMENT
   - code TEXT UNIQUE NOT NULL (e.g., "edit_content", "invite_collaborators")
   - category TEXT NOT NULL ("content", "structure", "course")
   - description TEXT

3. `role_permission` table - Many-to-many junction:
   - role_id INTEGER NOT NULL
   - permission_id INTEGER NOT NULL
   - PRIMARY KEY (role_id, permission_id)
   - FOREIGN KEY (role_id) REFERENCES course_role(id) ON DELETE CASCADE
   - FOREIGN KEY (permission_id) REFERENCES permission(id) ON DELETE CASCADE

4. `collaborator` table - Users linked to courses with roles:
   - id INTEGER PRIMARY KEY AUTOINCREMENT
   - course_id TEXT NOT NULL
   - user_id INTEGER NOT NULL
   - role_id INTEGER NOT NULL
   - invited_by INTEGER NOT NULL
   - invited_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   - FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
   - FOREIGN KEY (role_id) REFERENCES course_role(id)
   - FOREIGN KEY (invited_by) REFERENCES user(id)
   - UNIQUE(course_id, user_id) -- One role per user per course

Add index on collaborator.course_id for fast lookups.
  </action>
  <verify>sqlite3 -init instance/schema.sql :memory: ".tables" shows course_role, permission, role_permission, collaborator</verify>
  <done>Schema has 4 new collaboration tables with proper foreign keys and indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create permission definitions module</name>
  <files>src/collab/__init__.py, src/collab/permissions.py</files>
  <action>
Create src/collab/ package with permissions.py defining:

1. PERMISSIONS dict - All 13 permission codes organized by category:
   - content: view_content, edit_content, delete_content, generate_content, approve_content
   - structure: add_structure, reorder_structure, delete_structure, manage_outcomes
   - course: invite_collaborators, export_course, publish_course, delete_course

2. ROLE_TEMPLATES dict - 4 predefined role permission sets:
   - Owner: all 13 permissions
   - Designer: view_content, edit_content, generate_content, add_structure, reorder_structure, manage_outcomes, export_course
   - Reviewer: view_content, approve_content, export_course
   - SME: view_content, export_course

3. Helper functions:
   - `seed_permissions(db)` - Insert all permission codes into database (idempotent)
   - `has_permission(user_id, course_id, permission_code)` - Check if user has permission on course (uses get_db)
   - `get_user_permissions(user_id, course_id)` - Get all permission codes for user on course
   - `get_user_role(user_id, course_id)` - Get role name for user on course

Use get_db() from src.auth.db for database access.
  </action>
  <verify>python -c "from src.collab.permissions import PERMISSIONS, ROLE_TEMPLATES, has_permission; print(len(PERMISSIONS))"</verify>
  <done>Permission system with 13 codes, 4 role templates, and permission check functions</done>
</task>

<task type="auto">
  <name>Task 3: Create collaboration models</name>
  <files>src/collab/models.py, src/collab/__init__.py, requirements.txt</files>
  <action>
Create Role and Collaborator model classes in src/collab/models.py:

1. Role class:
   - Properties: id, course_id, name, created_at, permissions (list of codes)
   - Class methods:
     - `get_by_id(role_id)` - Load role with permissions
     - `create(course_id, name, permission_codes)` - Create role with permissions
     - `create_from_template(course_id, template_name)` - Create from ROLE_TEMPLATES
     - `get_for_course(course_id)` - List all roles for a course
     - `delete(role_id)` - Delete role (CASCADE removes role_permissions)
   - Instance method: `to_dict()` - Serialize for API

2. Collaborator class:
   - Properties: id, course_id, user_id, role_id, invited_by, invited_at, role_name, user_email, user_name
   - Class methods:
     - `get_by_id(collaborator_id)` - Load with joins for role/user info
     - `get_by_user_and_course(user_id, course_id)` - Find collaborator entry
     - `create(course_id, user_id, role_id, invited_by)` - Add collaborator
     - `get_for_course(course_id)` - List all collaborators on course
     - `delete(collaborator_id)` - Remove collaborator
     - `update_role(collaborator_id, new_role_id)` - Change role
   - Instance method: `to_dict()` - Serialize for API

Add jsondiff>=2.2.0 to requirements.txt (needed for audit trail in later plan).

Update src/collab/__init__.py to export Role, Collaborator, PERMISSIONS, ROLE_TEMPLATES, has_permission.
  </action>
  <verify>python -c "from src.collab import Role, Collaborator, has_permission; print('Models loaded')"</verify>
  <done>Role and Collaborator models with full CRUD operations and template support</done>
</task>

</tasks>

<verification>
1. Schema creates all 4 tables with correct relationships
2. Permission definitions cover all 13 codes in 3 categories
3. Role templates match phase context (Owner/Designer/Reviewer/SME)
4. Models support CRUD operations with proper joins
5. has_permission function queries database correctly
</verification>

<success_criteria>
- [ ] instance/schema.sql has course_role, permission, role_permission, collaborator tables
- [ ] PERMISSIONS dict has 13 codes in 3 categories
- [ ] ROLE_TEMPLATES dict has 4 templates with correct permission sets
- [ ] Role.create_from_template works for all 4 templates
- [ ] Collaborator.create links user to course with role
- [ ] has_permission returns True for granted permissions, False otherwise
- [ ] jsondiff added to requirements.txt
</success_criteria>

<output>
After completion, create `.planning/phases/10-collaboration-roles/10-01-SUMMARY.md`
</output>
