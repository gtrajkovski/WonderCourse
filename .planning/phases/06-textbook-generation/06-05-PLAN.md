---
phase: 06-textbook-generation
plan: 05
type: execute
wave: 3
depends_on: ["06-02", "06-03", "06-04"]
files_modified:
  - src/api/textbook.py
  - tests/test_textbook_api.py
  - src/core/models.py
  - app.py
autonomous: true

must_haves:
  truths:
    - "POST /api/courses/<id>/textbook/generate returns 202 with task_id for async generation"
    - "GET /api/jobs/<task_id> returns job status with progress, current_step, and result"
    - "Textbook generation runs in background thread; progress_callback wired from API to TextbookGenerator.generate_chapter() updates JobTracker at each internal step (outline, each section, assembly, validation)"
    - "Generated chapter is saved to course.textbook_chapters via ProjectStore"
    - "TextbookChapter model has image_placeholders and references fields"
    - "Job status progresses: pending -> running (with progress 0.1 to 0.9) -> completed"
    - "Generation errors result in job status 'failed' with error message"
  artifacts:
    - path: "src/api/textbook.py"
      provides: "Textbook generation API endpoints with async job tracking"
      exports: ["textbook_bp", "init_textbook_bp"]
      min_lines: 120
    - path: "tests/test_textbook_api.py"
      provides: "API integration tests"
      min_lines: 80
    - path: "src/core/models.py"
      provides: "Updated TextbookChapter with image_placeholders and references"
    - path: "app.py"
      provides: "Blueprint registration for textbook API"
  key_links:
    - from: "src/api/textbook.py"
      to: "src/generators/textbook_generator.py"
      via: "imports TextbookGenerator"
      pattern: "from src\\.generators\\.textbook_generator import TextbookGenerator"
    - from: "src/api/textbook.py"
      to: "src/api/job_tracker.py"
      via: "imports JobTracker for progress tracking"
      pattern: "from src\\.api\\.job_tracker import JobTracker"
    - from: "src/api/textbook.py"
      to: "src/utils/coherence_validator.py"
      via: "imports CoherenceValidator for post-generation checks"
      pattern: "from src\\.utils\\.coherence_validator import CoherenceValidator"
    - from: "src/api/textbook.py"
      to: "src/generators/textbook_generator.py"
      via: "passes progress_callback lambda to generate_chapter() that updates JobTracker"
      pattern: "generate_chapter\\(.*progress_callback"
    - from: "app.py"
      to: "src/api/textbook.py"
      via: "registers textbook_bp blueprint"
      pattern: "init_textbook_bp.*register_blueprint.*textbook_bp"
---

<objective>
Create the textbook API blueprint with async generation endpoints and wire everything together: TextbookGenerator, JobTracker, CoherenceValidator, and the Flask app.

Purpose: This is the integration layer that connects all Phase 6 components into a working API. Users can trigger textbook generation, poll for progress, and retrieve completed chapters.
Output: Working textbook API with 2 endpoints, updated TextbookChapter model, Flask app registration, and integration tests.
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-textbook-generation/06-02-SUMMARY.md
@.planning/phases/06-textbook-generation/06-03-SUMMARY.md
@.planning/phases/06-textbook-generation/06-04-SUMMARY.md
@src/api/content.py
@src/core/models.py
@app.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update TextbookChapter model and create textbook API blueprint</name>
  <files>src/core/models.py, src/api/textbook.py, app.py</files>
  <action>
**1. Update TextbookChapter in src/core/models.py:**
Add two new fields to the TextbookChapter dataclass:
- `image_placeholders: List[Dict[str, str]] = field(default_factory=list)` - Image placeholder data
- `references: List[Dict[str, str]] = field(default_factory=list)` - APA 7 reference data
- `coherence_issues: List[str] = field(default_factory=list)` - Issues found during validation

Update `to_dict()` to include these 3 new fields.
Update `from_dict()` - no changes needed since it uses known-field filtering (new fields auto-handled).

**2. Create src/api/textbook.py:**
Follow the blueprint init pattern from content.py (init_bp sets module-level _project_store).

Create `textbook_bp = Blueprint('textbook', __name__)` with `init_textbook_bp(project_store)`.

**Endpoint 1: POST /api/courses/<course_id>/textbook/generate**
Request JSON: `{"learning_outcome_id": "lo_xxx", "topic": "Machine Learning Basics"}`

Logic:
1. Load course, find learning outcome by ID (404 if not found)
2. Create job via JobTracker.create_job("textbook")
3. Start background thread that runs `_generate_with_progress(task_id, course_id, learning_outcome, topic)`
4. Return `{"task_id": task_id}` with status 202

**Background thread lifecycle:**
- Create thread: `threading.Thread(target=_generate_with_progress, args=(task_id, course_id, learning_outcome, topic), daemon=False)`
- `daemon=False` ensures generation completes even if main thread exits
- Thread is fire-and-forget from the POST handler's perspective
- No thread pool or cleanup needed (threads self-terminate after completion)

The background function `_generate_with_progress(task_id, course_id, learning_outcome, topic)`:
**Entire function body wrapped in try/except:**
```python
def _generate_with_progress(task_id, course_id, learning_outcome, topic):
    try:
        # 1. Define progress callback lambda that updates JobTracker
        def progress_callback(progress: float, step: str):
            JobTracker.update_job(task_id, status="running", progress=progress, current_step=step)

        # 2. Call generator with progress_callback wired in
        generator = TextbookGenerator()
        chapter_schema, metadata = generator.generate_chapter(
            learning_outcome.description, topic, "undergraduate",
            progress_callback=progress_callback
        )
        # generate_chapter internally calls progress_callback at:
        #   (0.1, "Generating chapter outline")
        #   (0.1 + i/N*0.5, "Generating section i/N: title") for each section
        #   (0.7, "Assembling chapter")

        # 3. Run coherence validation
        progress_callback(0.8, "Running coherence validation")
        validator = CoherenceValidator()
        issues = validator.check_consistency(chapter_schema.sections, chapter_schema.glossary_terms)

        # 4. Save chapter
        progress_callback(0.9, "Saving chapter")
        chapter = TextbookChapter(...)  # from generated content
        chapter.coherence_issues = issues
        course.textbook_chapters.append(chapter)
        _project_store.save_course(course)

        # 5. Complete
        JobTracker.update_job(task_id, status="completed", progress=1.0, result=chapter.to_dict())

    except Exception as e:
        import logging
        logging.getLogger(__name__).error(f"Textbook generation failed for job {task_id}: {e}")
        JobTracker.update_job(task_id, status="failed", error=str(e))
```

**Endpoint 2: GET /api/jobs/<task_id>**
Returns job status from JobTracker.get_job(task_id).
404 if task_id not found.
Returns JSON: {task_id, status, progress, current_step, result, error}

**3. Register blueprint in app.py:**
Add import and registration following existing pattern:
```python
from src.api.textbook import textbook_bp, init_textbook_bp
init_textbook_bp(project_store)
app.register_blueprint(textbook_bp)
```
  </action>
  <verify>
Run: `python -c "from src.api.textbook import textbook_bp, init_textbook_bp; print('Textbook blueprint importable')"` succeeds.
Run: `python -c "from src.core.models import TextbookChapter; ch = TextbookChapter(); d = ch.to_dict(); assert 'image_placeholders' in d; assert 'references' in d; assert 'coherence_issues' in d; print('Model updated')"` succeeds.
  </verify>
  <done>Textbook API blueprint created with generate and job status endpoints. TextbookChapter model updated. Blueprint registered in app.py.</done>
</task>

<task type="auto">
  <name>Task 2: Write textbook API integration tests</name>
  <files>tests/test_textbook_api.py</files>
  <action>
Create `tests/test_textbook_api.py` following the test pattern from test_content_api.py:

Use the existing `client` and `tmp_store` fixtures from conftest.py.
Mock the TextbookGenerator and CoherenceValidator to avoid real API calls.

Tests:

1. **test_generate_textbook_returns_202_with_task_id** - POST to generate endpoint returns 202 with task_id string. Mock TextbookGenerator so generate_chapter returns a valid TextbookChapterSchema. Use `mocker.patch('src.api.textbook.TextbookGenerator')`.

2. **test_generate_textbook_requires_learning_outcome_id** - POST without learning_outcome_id returns 400.

3. **test_generate_textbook_404_for_missing_course** - POST to nonexistent course returns 404.

4. **test_generate_textbook_404_for_missing_outcome** - POST with nonexistent learning_outcome_id returns 404.

5. **test_get_job_status** - Create a job via JobTracker, GET /api/jobs/<task_id> returns job details.

6. **test_get_job_status_404** - GET /api/jobs/nonexistent returns 404.

7. **test_textbook_chapter_saved_to_course** - After generation completes (wait for thread or mock threading), verify course.textbook_chapters has the new chapter.

8. **test_job_transitions_to_completed** - Verify job status transitions from pending -> running -> completed.

9. **test_job_transitions_to_failed_on_error** - Mock generator to raise exception, verify job status becomes "failed" with error message.

10. **test_updated_textbook_chapter_model** - Verify TextbookChapter.to_dict() includes image_placeholders, references, and coherence_issues fields.

For threading tests: either mock `threading.Thread` to run synchronously (target() called immediately) or use `time.sleep()` with short delays. Prefer mocking threading to make tests deterministic.

Important: Add a fixture or setup that calls `JobTracker.clear_jobs()` before each test to prevent state leakage.

Create a sample course with learning outcomes in the test setup, using the patterns from conftest.py (Course with modules, lessons, activities, and learning_outcomes).
  </action>
  <verify>Run: `python -m pytest tests/test_textbook_api.py -v` passes all 10 tests.</verify>
  <done>10 API integration tests passing, covering generate endpoint, job status polling, error handling, and model updates.</done>
</task>

</tasks>

<verification>
- POST /api/courses/<id>/textbook/generate returns 202 with task_id
- GET /api/jobs/<task_id> returns progress and status
- TextbookChapter model updated with new fields
- Blueprint registered in app.py
- All 10 tests pass
- Existing tests still pass: `python -m pytest` (300+ tests)
</verification>

<success_criteria>
- Async textbook generation with progress tracking via JobTracker
- Background thread handles multi-step generation pipeline
- Generated chapters saved to course.textbook_chapters
- Job status endpoint enables client-side progress polling
- TextbookChapter model supports image_placeholders, references, coherence_issues
- All tests pass including existing 300+ tests
</success_criteria>

<output>
After completion, create `.planning/phases/06-textbook-generation/06-05-SUMMARY.md`
</output>
