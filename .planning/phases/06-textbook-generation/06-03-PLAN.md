---
phase: 06-textbook-generation
plan: 03
type: tdd
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/generators/textbook_generator.py
  - tests/test_textbook_generator.py
autonomous: true

must_haves:
  truths:
    - "TextbookGenerator extends BaseGenerator with hierarchical generation"
    - "generate_outline() produces structured outline with 5-8 sections from learning outcome"
    - "generate_section() produces section content with context from previous sections"
    - "generate_chapter() orchestrates full pipeline: outline -> sections -> assembly into TextbookChapterSchema, with optional progress_callback at each step"
    - "System prompt enforces academic writing, ~3000 word target, and APA 7 references"
    - "Metadata includes word_count, estimated_duration_minutes, section_count, reference_count, glossary_count, image_count"
  artifacts:
    - path: "src/generators/textbook_generator.py"
      provides: "TextbookGenerator with hierarchical expansion"
      exports: ["TextbookGenerator"]
      min_lines: 150
    - path: "tests/test_textbook_generator.py"
      provides: "Generator tests with mocked Anthropic API"
      min_lines: 100
  key_links:
    - from: "src/generators/textbook_generator.py"
      to: "src/generators/base_generator.py"
      via: "extends BaseGenerator[TextbookChapterSchema]"
      pattern: "class TextbookGenerator\\(BaseGenerator"
    - from: "src/generators/textbook_generator.py"
      to: "src/generators/schemas/textbook.py"
      via: "imports all textbook schemas"
      pattern: "from src\\.generators\\.schemas\\.textbook import"
---

<objective>
Build the TextbookGenerator that uses hierarchical expansion to produce ~3000-word chapters: first generating an outline, then expanding each section with context from previous sections, and assembling the final chapter.

Purpose: This is the core generation engine for Phase 6. It handles the multi-step LLM workflow that produces coherent long-form content by generating sections sequentially with accumulated context.
Output: Working TextbookGenerator with hierarchical generation, tested with mocked API.
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/generators/base_generator.py
@src/generators/reading_generator.py
@src/generators/schemas/textbook.py
@tests/test_reading_generator.py
</context>

<feature>
  <name>TextbookGenerator with Hierarchical Expansion</name>
  <files>src/generators/textbook_generator.py, tests/test_textbook_generator.py</files>
  <behavior>
  The TextbookGenerator extends BaseGenerator[TextbookChapterSchema] and implements hierarchical expansion:

  **generate_outline(learning_objective, topic, audience_level) -> TextbookOutlineSchema:**
  - Calls Claude API with outline-specific prompt
  - Returns structured outline with 5-8 sections, each with title, description, estimated_words
  - Uses TextbookOutlineSchema for structured output

  **generate_section(section_outline, chapter_context, covered_concepts) -> TextbookSectionSchema:**
  - Generates single section with context from outline and previous sections
  - Prevents redundancy by passing covered_concepts list
  - Uses TextbookSectionSchema for structured output

  **generate_chapter(learning_objective, topic, audience_level, progress_callback=None) -> Tuple[TextbookChapterSchema, dict]:**
  - Accepts optional `progress_callback: Optional[Callable[[float, str], None]]` parameter
    - Called as `progress_callback(progress_float, step_description)` at each internal step
    - If None, no-op (backward compatible)
  - Orchestrates full pipeline:
    1. `progress_callback(0.1, "Generating chapter outline")` if provided
    2. Generate outline
    3. For each section i of N: `progress_callback(0.1 + (i/N)*0.5, f"Generating section {i+1}/{N}: {title}")` if provided
    4. Generate each section sequentially, accumulating covered_concepts
    5. `progress_callback(0.7, "Assembling chapter")` if provided
    6. Make one final API call to assemble the complete TextbookChapterSchema (with introduction, conclusion, references, glossary_terms, image_placeholders)
  - Returns (chapter, metadata) tuple

  **extract_metadata(content: TextbookChapterSchema) -> dict:**
  - word_count: Total words across introduction + all sections + conclusion
  - estimated_duration_minutes: word_count / 238 (reading rate)
  - content_type: "textbook_chapter"
  - section_count: len(sections)
  - reference_count: len(references)
  - glossary_count: len(glossary_terms)
  - image_count: len(image_placeholders)

  **system_prompt:**
  - Role: Expert textbook author for higher education
  - Guidelines: Academic writing, ~3000 word target, progressive concept building
  - APA 7 citation format (copy examples from ReadingGenerator)
  - No redundancy between sections
  - Image placeholder expectations

  **build_user_prompt(learning_objective, topic, audience_level):**
  - Standard prompt for the final assembly call
  - Includes learning outcome, topic, audience level

  Test cases:
  - generate() returns valid TextbookChapterSchema with all fields
  - system_prompt contains "textbook" and "APA 7"
  - build_user_prompt includes all parameters
  - extract_metadata calculates word count correctly
  - metadata uses 238 WPM reading rate
  - API called with output_config parameter
  - generate_chapter orchestrates outline + sections + assembly (3+ API calls)
  - generate_chapter calls progress_callback at each step when provided
  - generate_chapter works without progress_callback (backward compatible)
  </behavior>
  <implementation>
  The generator needs multiple API calls internally. The approach:

  1. `generate_outline()` makes one API call with TextbookOutlineSchema
  2. For each section in outline, `generate_section()` makes one API call with TextbookSectionSchema
  3. `generate_chapter()` calls generate_outline, then generate_section for each, then makes a FINAL call using the base `generate()` method with TextbookChapterSchema that includes all generated sections in the prompt
  4. `generate_chapter()` accepts `progress_callback: Optional[Callable[[float, str], None]] = None`. If provided, it is called before each major step with (progress_float, step_description). This allows the API layer to wire in JobTracker updates without the generator knowing about jobs.

  For the final assembly call, the user prompt will contain ALL generated section content so Claude can write the introduction, conclusion, references, glossary terms, and image placeholders with full chapter context.

  The `generate_outline()` and `generate_section()` methods bypass the base `generate()` and call `self.client.messages.create()` directly with their specific schemas (since base generate() uses build_user_prompt which is for the final assembly).

  Mock testing: Mock `src.generators.base_generator.Anthropic` as in all other generators. Set up mock to return different JSON responses for different calls (outline first, then sections, then final chapter).
  </implementation>
</feature>

<verification>
- TextbookGenerator importable from `src.generators.textbook_generator`
- All tests pass with mocked Anthropic API
- Generator produces valid TextbookChapterSchema
- Metadata calculations are correct
- Existing tests still pass: `python -m pytest` (300+ tests)
</verification>

<success_criteria>
- TextbookGenerator extends BaseGenerator[TextbookChapterSchema]
- Hierarchical expansion: outline -> sections -> assembly
- System prompt includes academic writing guidelines and APA 7 examples
- Metadata includes all 7 fields (word_count, duration, section/reference/glossary/image counts)
- All tests pass with mocked API
</success_criteria>

<output>
After completion, create `.planning/phases/06-textbook-generation/06-03-SUMMARY.md`
</output>
