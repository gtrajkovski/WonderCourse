---
phase: 13-integration-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - static/js/utils/error-recovery.js
  - static/js/utils/api.js
  - static/css/components/loading.css
  - templates/partials/skeleton.html
  - static/js/components/skeleton.js
autonomous: true

must_haves:
  truths:
    - "API calls auto-retry on 5xx errors with exponential backoff"
    - "Users see skeleton screens during page loads"
    - "Timeout warnings appear with cancel/retry options"
    - "Different operations have appropriate timeout thresholds"
  artifacts:
    - path: "static/js/utils/error-recovery.js"
      provides: "Frontend retry logic with fetchWithRetry"
      exports: ["ErrorRecovery"]
    - path: "static/css/components/loading.css"
      provides: "Skeleton screen animations"
      contains: "@keyframes skeleton-loading"
    - path: "templates/partials/skeleton.html"
      provides: "Reusable skeleton partials"
      contains: "skeleton-"
  key_links:
    - from: "static/js/utils/api.js"
      to: "static/js/utils/error-recovery.js"
      via: "ErrorRecovery.fetchWithRetry"
      pattern: "fetchWithRetry"
---

<objective>
Implement frontend error recovery with auto-retry, skeleton loading screens, and operation-specific timeouts.

Purpose: Provide graceful handling of transient failures and clear visual feedback during loading states so users understand what's happening.
Output: Error recovery utilities, skeleton screens, and timeout handling with visual indicators.
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-integration-polish/13-CONTEXT.md
@.planning/phases/13-integration-polish/13-RESEARCH.md
@static/js/utils/api.js
@static/js/utils/toast.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create frontend error recovery with retry logic</name>
  <files>static/js/utils/error-recovery.js, static/js/utils/api.js</files>
  <action>
Create static/js/utils/error-recovery.js with ErrorRecovery class:

1. TIMEOUTS constant object:
   - SAVE: 30000 (30s for quick saves)
   - GENERATE: 90000 (90s for content generation)
   - TEXTBOOK: 120000 (2min for textbook/export)
   - STREAM: 0 (no timeout for SSE streams)

2. fetchWithRetry(url, options, maxAttempts = 3) async method:
   - Uses AbortController for timeout based on operation type
   - Retries on 5xx errors with exponential backoff + jitter
   - Does NOT retry 4xx errors (client errors)
   - Shows toast on final failure
   - Logs technical details to console

3. handleApiError(error, retryFn, context) method:
   - For 502/503: Shows "Server temporarily unavailable" with Retry button
   - For 400: Shows inline field error if error.field present, else toast
   - For 401: Redirects to login
   - For 403: Shows permission denied message
   - For 429: Shows rate limit message with retry-after time
   - For unknown: Generic toast with console details

4. showTimeoutDialog(operationName, retryFn, cancelFn) method:
   - Modal dialog: "This operation is taking longer than expected"
   - Options: "Keep Waiting" (extends timeout), "Retry" (calls retryFn), "Cancel" (calls cancelFn)

Update static/js/utils/api.js:
- Import ErrorRecovery (via window.errorRecovery)
- Modify request() to use fetchWithRetry for POST/PUT/DELETE
- Add operationType option to specify timeout category
- Add retry option (default true for mutations, false for reads)
  </action>
  <verify>Open browser console, check window.errorRecovery exists with fetchWithRetry method</verify>
  <done>API client uses retry logic for mutations, different timeouts per operation type</done>
</task>

<task type="auto">
  <name>Task 2: Create skeleton screen components</name>
  <files>static/css/components/loading.css, templates/partials/skeleton.html, static/js/components/skeleton.js</files>
  <action>
Create static/css/components/loading.css:

1. .skeleton-item base class:
   - height: 40px, margin: 8px 0
   - background: linear gradient for shimmer effect
   - animation: skeleton-loading 1.5s infinite
   - border-radius: 4px

2. @keyframes skeleton-loading:
   - 0%: background-position 200% 0
   - 100%: background-position -200% 0

3. Skeleton variants:
   - .skeleton-text (height: 16px for text lines)
   - .skeleton-title (height: 24px, width: 60%)
   - .skeleton-avatar (40px circle)
   - .skeleton-card (full card placeholder)
   - .skeleton-tree-item (for builder tree)

4. Container state:
   - [data-loading="true"] .skeleton-* { display: block }
   - [data-loading="true"] .real-content { display: none }
   - [data-loading="false"] .skeleton-* { display: none }
   - [data-loading="false"] .real-content { display: block }

Create templates/partials/skeleton.html with Jinja2 macros:
- {{ skeleton_card() }} - course card skeleton
- {{ skeleton_list(count=5) }} - list of skeleton items
- {{ skeleton_tree() }} - tree structure skeleton
- {{ skeleton_content() }} - content preview skeleton

Create static/js/components/skeleton.js:
- SkeletonManager class
- show(containerId) - sets data-loading="true"
- hide(containerId) - sets data-loading="false"
- withSkeleton(containerId, asyncFn) - shows skeleton, runs async, hides skeleton
  </action>
  <verify>python app.py, view any page with skeleton in devtools (manually add data-loading="true")</verify>
  <done>Skeleton screens styled and ready for integration into pages</done>
</task>

<task type="auto">
  <name>Task 3: Integrate loading states into key pages</name>
  <files>templates/dashboard.html, templates/studio.html, static/js/pages/dashboard.js, static/js/pages/studio.js</files>
  <action>
Update templates/dashboard.html:
- Add skeleton cards grid inside courses container
- Set initial data-loading="true"
- Wrap real course cards in .real-content div

Update static/js/pages/dashboard.js:
- Use skeleton.withSkeleton() when loading courses
- Add elapsed time display for loads over 2 seconds
- Show "Loading courses..." message initially

Update templates/studio.html:
- Add skeleton for activity list sidebar
- Add skeleton for content preview area
- Set initial data-loading="true" for both sections

Update static/js/pages/studio.js:
- Use skeleton.withSkeleton() for initial load
- Use skeleton for activity selection transitions
- For AI generation, use streaming preview (already implemented), not skeleton
  </action>
  <verify>Run app, visit dashboard and studio pages, observe skeleton during load</verify>
  <done>Dashboard and studio show skeleton screens during loading, smooth transitions</done>
</task>

</tasks>

<verification>
- Skeleton CSS loads and animates correctly
- fetchWithRetry retries 5xx errors, not 4xx
- Timeout dialog appears after threshold
- Dashboard shows skeleton on initial load
- Studio shows skeleton when switching activities
</verification>

<success_criteria>
- Skeleton screens visible during page loads
- API retries with exponential backoff
- Timeout warnings with cancel/retry options
- Different timeouts for different operation types
- Smooth loading experience on dashboard and studio
</success_criteria>

<output>
After completion, create `.planning/phases/13-integration-polish/13-02-SUMMARY.md`
</output>
