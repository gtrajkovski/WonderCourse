---
phase: 13-integration-polish
plan: 05
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/api/courses.py
  - src/api/modules.py
  - static/js/utils/lazy-loader.js
  - tests/test_performance.py
autonomous: true

must_haves:
  truths:
    - "Dashboard loads quickly with many courses (20+)"
    - "Module content loads on demand, not all at once"
    - "Activity pagination works for large lessons"
    - "Large course operations complete within timeout thresholds"
  artifacts:
    - path: "static/js/utils/lazy-loader.js"
      provides: "Client-side lazy loading utilities"
      exports: ["LazyLoader"]
    - path: "src/api/courses.py"
      provides: "Paginated course listing"
      contains: "page"
  key_links:
    - from: "static/js/pages/dashboard.js"
      to: "static/js/utils/lazy-loader.js"
      via: "LazyLoader for course cards"
      pattern: "LazyLoader"
---

<objective>
Optimize performance for large courses with lazy loading, pagination, and efficient data loading patterns.

Purpose: Ensure the application remains responsive with courses containing 20+ activities, avoiding slow page loads and memory issues.
Output: Lazy loading utilities, paginated APIs, and performance tests.
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-integration-polish/13-CONTEXT.md
@.planning/phases/13-integration-polish/13-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pagination to course and activity listing APIs</name>
  <files>src/api/courses.py, app.py</files>
  <action>
Update the course listing in app.py (GET /api/courses):

1. Add query parameters:
   - page (default 1)
   - per_page (default 20, max 100)
   - summary_only (default true) - if true, return only metadata not full content

2. When summary_only=true, return lightweight response:
   ```python
   {
       "id": course.id,
       "title": course.title,
       "description": course.description[:200],  # Truncate
       "module_count": len(course.modules),
       "activity_count": count_activities(course),
       "build_state": compute_build_state(course),
       "updated_at": course.updated_at
   }
   ```

3. Add pagination metadata to response:
   ```python
   {
       "courses": [...],
       "page": page,
       "per_page": per_page,
       "total": total_count,
       "has_more": page * per_page < total_count
   }
   ```

Create helper function count_activities(course) that traverses structure without loading content.

Add similar pagination to GET /api/courses/{id}/modules/{mid}/lessons/{lid}/activities:
- page, per_page parameters
- Return activity summaries without full content
  </action>
  <verify>curl "/api/courses?page=1&per_page=5&summary_only=true" returns paginated response</verify>
  <done>Course and activity APIs support pagination and summary-only mode</done>
</task>

<task type="auto">
  <name>Task 2: Create client-side lazy loader</name>
  <files>static/js/utils/lazy-loader.js, static/js/pages/builder.js</files>
  <action>
Create static/js/utils/lazy-loader.js with LazyLoader class:

1. Constructor(options):
   - containerId: where to render items
   - fetchFn: async function(page) that returns items
   - renderFn: function(item) returns HTML string
   - perPage: items per load (default 20)

2. init() method:
   - Fetch first page
   - Render items
   - Add scroll listener for infinite scroll (optional)
   - Add "Load More" button

3. loadMore() method:
   - Increment page
   - Fetch next page
   - Append to container
   - Hide button if no more

4. refresh() method:
   - Reset to page 1
   - Clear container
   - Fetch and render

5. Intersection Observer for lazy loading:
   - When last item enters viewport, auto-load more

Create ModuleLoader class extending LazyLoader:
- Tracks which modules have been expanded
- loadModuleContent(moduleId) fetches lessons/activities on demand
- Caches loaded content to avoid re-fetching

Update static/js/pages/builder.js:
- Use ModuleLoader for tree view
- Only fetch module content when user expands module
- Show skeleton while loading module content
  </action>
  <verify>Open builder page, expand module, observe network request for module content</verify>
  <done>Lazy loader works, modules load on demand</done>
</task>

<task type="auto">
  <name>Task 3: Create performance tests</name>
  <files>tests/test_performance.py</files>
  <action>
Create tests/test_performance.py with performance benchmarks:

1. test_dashboard_load_with_20_courses(client):
   - Create 20 courses via API
   - Time GET /api/courses with summary_only=true
   - Assert < 500ms response time
   - Assert response size < 100KB

2. test_large_course_load(client):
   - Create course with 3 modules, 10 lessons each, 5 activities per lesson (150 activities)
   - Time GET /api/courses/{id}
   - Assert < 1000ms response time

3. test_activity_pagination_performance(client):
   - Create lesson with 50 activities
   - Time paginated fetch (page=1, per_page=20)
   - Assert < 200ms response time

4. test_blueprint_generation_timeout(client, mocker):
   - Mock AI to delay 5 seconds
   - Verify request doesn't hang
   - Verify timeout handling works

5. test_concurrent_course_access(client):
   - Simulate 5 concurrent requests to same course
   - Verify no file locking issues
   - All requests succeed

Use pytest-benchmark if available, otherwise manual timing with time.perf_counter().

Mark tests with @pytest.mark.slow for optional skip in quick runs.
  </action>
  <verify>pytest tests/test_performance.py -v</verify>
  <done>Performance tests verify acceptable response times for large datasets</done>
</task>

</tasks>

<verification>
- Dashboard loads in < 500ms with 20 courses
- Module content loads on expand, not on page load
- Activity list paginates correctly
- Performance tests pass
- No memory issues with large courses
</verification>

<success_criteria>
- Pagination working on course and activity APIs
- Lazy loading reduces initial page load
- Performance tests establish baselines
- Builder tree loads modules on demand
- Dashboard handles 20+ courses efficiently
</success_criteria>

<output>
After completion, create `.planning/phases/13-integration-polish/13-05-SUMMARY.md`
</output>
