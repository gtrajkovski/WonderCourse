---
phase: 13-integration-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/retry.py
  - src/utils/error_handlers.py
  - src/api/errors.py
  - app.py
  - tests/test_retry.py
  - tests/test_error_handlers.py
autonomous: true

must_haves:
  truths:
    - "Transient API failures retry with exponential backoff"
    - "All API errors return consistent JSON format"
    - "Flask error handlers convert exceptions to JSON responses"
    - "AI API calls have 3 retries with jitter"
  artifacts:
    - path: "src/utils/retry.py"
      provides: "Tenacity retry decorators"
      exports: ["ai_retry", "file_retry"]
    - path: "src/utils/error_handlers.py"
      provides: "Flask error handler registration"
      exports: ["register_error_handlers"]
    - path: "src/api/errors.py"
      provides: "Custom exception classes"
      exports: ["APIError", "ValidationError", "NotFoundError"]
  key_links:
    - from: "app.py"
      to: "src/utils/error_handlers.py"
      via: "register_error_handlers(app)"
      pattern: "register_error_handlers"
    - from: "src/generators/base_generator.py"
      to: "src/utils/retry.py"
      via: "@ai_retry decorator"
      pattern: "@ai_retry"
---

<objective>
Implement server-side error handling infrastructure with retry logic for transient failures and consistent JSON error responses.

Purpose: Establish robust error handling that auto-retries transient failures (network, 5xx) while providing consistent, user-friendly error messages for all API endpoints.
Output: Error utilities (retry.py, error_handlers.py, errors.py) with comprehensive test coverage.
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-integration-polish/13-CONTEXT.md
@.planning/phases/13-integration-polish/13-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create retry decorators with Tenacity</name>
  <files>src/utils/retry.py, requirements.txt</files>
  <action>
Add tenacity to requirements.txt.

Create src/utils/retry.py with:

1. ai_retry decorator for AI API calls:
   - 3 attempts max (stop_after_attempt(3))
   - Exponential backoff with jitter (wait_random_exponential, multiplier=1, min=4, max=10)
   - Retry on TimeoutError, ConnectionError, and anthropic.APIError
   - Log retries at WARNING level with before_sleep_log

2. file_retry decorator for file operations:
   - 5 attempts max
   - Shorter backoff (min=1, max=5)
   - Retry on IOError, OSError, PermissionError

3. network_retry decorator for general HTTP:
   - 3 attempts
   - Backoff with jitter
   - Retry on ConnectionError, TimeoutError

Include docstrings explaining when to use each decorator.
  </action>
  <verify>python -c "from src.utils.retry import ai_retry, file_retry, network_retry; print('Retry decorators imported successfully')"</verify>
  <done>Three retry decorators available for AI, file, and network operations with appropriate backoff strategies</done>
</task>

<task type="auto">
  <name>Task 2: Create custom exception classes and Flask error handlers</name>
  <files>src/api/errors.py, src/utils/error_handlers.py, app.py</files>
  <action>
Create src/api/errors.py with custom exception classes:
- APIError(message, status_code=500, payload=None) - base API exception
- ValidationError(message, field=None) - 400 status, for invalid input
- NotFoundError(resource_type, resource_id) - 404 status, formats "Course crs_123 not found"
- AuthorizationError(message) - 403 status, for permission denied
- RateLimitError(message, retry_after=60) - 429 status, includes Retry-After header
- AIServiceError(message, original_error=None) - 502 status, for AI API failures

Each exception should have:
- to_dict() method returning {"error": message, "code": status_code, ...optional fields}
- __str__ for logging

Create src/utils/error_handlers.py with register_error_handlers(app) function:
1. @app.errorhandler(APIError) - handles all custom exceptions
2. @app.errorhandler(HTTPException) - converts Werkzeug exceptions to JSON
3. @app.errorhandler(Exception) - catches unexpected errors, logs traceback, returns 500

Handler should:
- Log all 5xx errors with full context (user_id if available, request.path, traceback)
- Return consistent JSON format: {"error": message, "code": status_code}
- For RateLimitError, include Retry-After response header

Update app.py to call register_error_handlers(app) after app creation.
  </action>
  <verify>pytest tests/test_error_handlers.py -v</verify>
  <done>All Flask errors return JSON with consistent structure, custom exceptions available for use in routes</done>
</task>

<task type="auto">
  <name>Task 3: Create tests for retry and error handling</name>
  <files>tests/test_retry.py, tests/test_error_handlers.py</files>
  <action>
Create tests/test_retry.py:
1. test_ai_retry_succeeds_on_first_try - function succeeds, no retry
2. test_ai_retry_succeeds_after_transient_failure - fails once, succeeds on retry
3. test_ai_retry_raises_after_max_attempts - fails 3 times, raises
4. test_ai_retry_no_retry_on_permanent_error - ValueError not retried
5. test_file_retry_handles_permission_error - retries PermissionError
6. test_network_retry_with_connection_error - retries ConnectionError

Use unittest.mock to simulate failures.

Create tests/test_error_handlers.py:
1. test_validation_error_returns_400 - ValidationError serialized correctly
2. test_not_found_error_returns_404 - NotFoundError includes resource info
3. test_ai_service_error_returns_502 - AIServiceError logged and returned
4. test_rate_limit_error_includes_retry_after - Header present in response
5. test_werkzeug_exception_converted_to_json - abort(404) returns JSON
6. test_unexpected_exception_returns_500 - Random exception gives 500 JSON
7. test_exception_logging_includes_context - Check logger captured context

Test the error handlers by importing the Flask app and using test_client.
  </action>
  <verify>pytest tests/test_retry.py tests/test_error_handlers.py -v</verify>
  <done>All retry and error handling tests pass, coverage for normal and edge cases</done>
</task>

</tasks>

<verification>
- All new tests pass: pytest tests/test_retry.py tests/test_error_handlers.py -v
- Existing tests still pass: pytest tests/ -v --ignore=tests/e2e
- Retry decorators importable without side effects
- Error handlers registered in app startup
</verification>

<success_criteria>
- Tenacity installed and retry decorators working
- All API errors return consistent JSON format
- Custom exceptions cover common error cases
- 13+ tests for retry and error handling
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/13-integration-polish/13-01-SUMMARY.md`
</output>
