---
phase: 12-ai-interactive-features
plan: 03
type: execute
wave: 2
depends_on: [12-01, 12-02]
files_modified:
  - src/import/analyzer.py
  - src/import/importer.py
  - src/import/__init__.py
  - src/api/import_bp.py
  - app.py
  - tests/test_import_api.py
autonomous: true

must_haves:
  truths:
    - "User can upload content via API and receive analysis"
    - "System auto-detects format and selects appropriate parser"
    - "Imported content includes Bloom's level detection"
    - "Import handles conflicts with existing content"
  artifacts:
    - path: "src/import/analyzer.py"
      provides: "AI-powered content analysis"
      exports: ["ContentAnalyzer"]
    - path: "src/import/importer.py"
      provides: "Import orchestration"
      exports: ["ImportPipeline"]
    - path: "src/api/import_bp.py"
      provides: "Import API endpoints"
      exports: ["init_import_bp"]
  key_links:
    - from: "src/api/import_bp.py"
      to: "ImportPipeline"
      via: "import and call"
      pattern: "pipeline\\.import_content"
    - from: "src/import/importer.py"
      to: "parsers"
      via: "format detection and dispatch"
      pattern: "parser\\.parse\\("
---

<objective>
Build the content import pipeline with AI analysis and API endpoints.

Purpose: Enable users to upload content in any supported format, have it auto-analyzed for Bloom's level and structure, and imported into the course (IMPORT-01, IMPORT-02, IMPORT-03, IMPORT-04).
Output: Working import API that accepts files/text and returns analyzed, structured content.
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-ai-interactive-features/12-RESEARCH.md

# Existing API patterns
@src/api/content.py
@app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ContentAnalyzer and ImportPipeline</name>
  <files>
    src/import/analyzer.py
    src/import/importer.py
    src/import/__init__.py
  </files>
  <action>
1. Create `src/import/analyzer.py` with ContentAnalyzer class:
   - analyze(content: dict) -> AnalysisResult
   - Uses Claude API to analyze content for:
     - Suggested content type (video_script, reading, quiz, etc.)
     - Bloom's level detection based on verbs and structure
     - Word count and estimated duration
     - Structure completeness (missing sections, etc.)
   - Returns AnalysisResult dataclass with:
     - suggested_type: str
     - bloom_level: BloomLevel
     - word_count: int
     - estimated_duration: int (minutes)
     - structure_issues: List[str]
     - suggestions: List[str]
   - Include non-AI fallback for basic analysis (keyword matching) when API unavailable

2. Create `src/import/importer.py` with ImportPipeline class:
   - __init__ registers all parsers in dict by format
   - detect_format(source: str | bytes, filename: str = None) -> str
     - Try each parser's can_parse(), return first match
     - Use filename extension as hint
   - import_content(source, format_hint=None, analyze=True) -> ImportResult
     - Detect format if not provided
     - Parse with appropriate parser
     - Run AI analysis if analyze=True
     - Return ImportResult with content + analysis
   - ImportResult dataclass:
     - parse_result: ParseResult
     - analysis: Optional[AnalysisResult]
     - format_detected: str

3. Update `src/import/__init__.py` to export all classes
  </action>
  <verify>
    python -c "from src.import import ImportPipeline, ContentAnalyzer; print('Imports OK')"
  </verify>
  <done>
    ImportPipeline auto-detects format, parses, and analyzes content
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Import API Blueprint with tests</name>
  <files>
    src/api/import_bp.py
    app.py
    tests/test_import_api.py
  </files>
  <action>
1. Create `src/api/import_bp.py`:
   - init_import_bp(project_store) -> Blueprint following existing pattern
   - Endpoints:

   POST /api/import/analyze
   - Accepts: multipart/form-data with 'file' or JSON with 'content' (text)
   - Optional: format_hint query param
   - Returns: {format_detected, parse_result, analysis}
   - Does NOT save content, just returns analysis

   POST /api/courses/<course_id>/import
   - Accepts: multipart/form-data with 'file' or JSON with 'content'
   - Optional: target_type (activity|blueprint), target_id, conflict_action (replace|merge|cancel)
   - If blueprint: replace course structure
   - If activity content: update activity's content field
   - Returns: {imported: true, content_type, target, conflicts_resolved}
   - Requires login and course access permissions

   POST /api/courses/<course_id>/activities/<activity_id>/import
   - Import content directly into specific activity
   - Converts to activity's content type if needed
   - Returns: {imported: true, content, analysis}

2. Register blueprint in app.py with init_import_bp(project_store)

3. Create `tests/test_import_api.py`:
   - Test analyze endpoint with text content
   - Test analyze endpoint with file upload
   - Test format auto-detection
   - Test import into course (blueprint)
   - Test import into activity
   - Test conflict handling
   - Test authentication required
   - Mock AI client for analysis tests
  </action>
  <verify>
    pytest tests/test_import_api.py -v
  </verify>
  <done>
    Import API endpoints work with file upload, text paste, and format detection
  </done>
</task>

</tasks>

<verification>
- ImportPipeline detects formats and routes to correct parser
- ContentAnalyzer uses Claude API with fallback
- API accepts file upload and text paste
- Analysis returns Bloom's level, word count, suggestions
- Import saves content to course/activity
- All tests pass (target: 15+ tests)
</verification>

<success_criteria>
- POST /api/import/analyze returns format detection and AI analysis
- POST /api/courses/{id}/import handles blueprint imports
- POST /api/courses/{id}/activities/{id}/import handles content imports
- Conflict resolution works (replace/merge/cancel)
- All tests pass with mocked AI client
</success_criteria>

<output>
After completion, create `.planning/phases/12-ai-interactive-features/12-03-SUMMARY.md`
</output>
