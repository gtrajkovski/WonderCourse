---
phase: 12-ai-interactive-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/import/__init__.py
  - src/import/parsers/__init__.py
  - src/import/parsers/base_parser.py
  - src/import/parsers/text_parser.py
  - src/import/parsers/json_parser.py
  - src/import/parsers/markdown_parser.py
  - src/import/parsers/csv_parser.py
  - src/import/parsers/zip_parser.py
  - tests/test_import_parsers.py
autonomous: true

must_haves:
  truths:
    - "System can parse plain text into course content"
    - "System can parse JSON blueprints into course structure"
    - "System can parse Markdown into structured content"
    - "System can parse CSV into quiz questions"
    - "System can extract and list files from ZIP archives"
  artifacts:
    - path: "src/import/parsers/base_parser.py"
      provides: "Abstract base parser class"
      exports: ["BaseParser"]
    - path: "src/import/parsers/text_parser.py"
      provides: "Plain text parsing"
      exports: ["TextParser"]
    - path: "src/import/parsers/json_parser.py"
      provides: "JSON blueprint parsing"
      exports: ["JSONParser"]
    - path: "src/import/parsers/markdown_parser.py"
      provides: "Markdown content parsing"
      exports: ["MarkdownParser"]
    - path: "src/import/parsers/csv_parser.py"
      provides: "CSV quiz parsing"
      exports: ["CSVParser"]
    - path: "src/import/parsers/zip_parser.py"
      provides: "Generic ZIP archive parsing"
      exports: ["ZIPParser"]
  key_links:
    - from: "src/import/parsers/*.py"
      to: "BaseParser"
      via: "inheritance"
      pattern: "class.*Parser\\(BaseParser\\)"
---

<objective>
Build the core content import parsers for plain text, JSON, Markdown, CSV, and ZIP formats.

Purpose: Enable users to import existing content from common formats into Course Builder. These parsers form the foundation for the import pipeline (IMPORT-07).
Output: Five working parsers with consistent interface for format-agnostic content import.
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-ai-interactive-features/12-RESEARCH.md

# Existing patterns
@src/generators/base_generator.py
@src/core/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create base parser infrastructure</name>
  <files>
    src/import/__init__.py
    src/import/parsers/__init__.py
    src/import/parsers/base_parser.py
  </files>
  <action>
Create the import package structure with an abstract BaseParser class:

1. Create `src/import/__init__.py` - empty package init
2. Create `src/import/parsers/__init__.py` - exports all parsers
3. Create `src/import/parsers/base_parser.py` with:
   - `BaseParser` ABC with abstract methods:
     - `parse(source: str | bytes) -> ParseResult` - parse content from string or bytes
     - `can_parse(source: str | bytes, filename: str = None) -> bool` - detect if this parser handles the format
   - `ParseResult` dataclass with:
     - `content_type: str` - detected content type (blueprint, video_script, reading, quiz, etc.)
     - `content: dict` - parsed content in normalized format
     - `metadata: dict` - source metadata (word_count, format, detected_structure)
     - `warnings: List[str]` - non-fatal parsing issues
     - `provenance: dict` - source tracking (filename, import_time, original_format)

Use the same ABC pattern as BaseGenerator. ParseResult should be serializable via to_dict().
  </action>
  <verify>
    python -c "from src.import.parsers import BaseParser, ParseResult; print('Imports OK')"
  </verify>
  <done>
    BaseParser ABC and ParseResult dataclass importable with all required methods/fields
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement text, JSON, Markdown, CSV, and ZIP parsers</name>
  <files>
    src/import/parsers/text_parser.py
    src/import/parsers/json_parser.py
    src/import/parsers/markdown_parser.py
    src/import/parsers/csv_parser.py
    src/import/parsers/zip_parser.py
    src/import/parsers/__init__.py
    tests/test_import_parsers.py
  </files>
  <action>
Implement five parsers extending BaseParser:

1. **TextParser** (`text_parser.py`):
   - Parses plain text content
   - Detects structure: headings (lines ending with :), paragraphs, lists (lines starting with - or *)
   - Estimates Bloom's level based on keywords (analyze, evaluate, create = higher levels)
   - Returns content_type based on detected structure (reading, video_script, etc.)
   - can_parse: True for any non-empty string without JSON/Markdown markers

2. **JSONParser** (`json_parser.py`):
   - Parses JSON blueprints and course structures
   - Validates against expected blueprint schema (modules, lessons, activities)
   - Maps to Course/Module/Lesson/Activity structure from models.py
   - Returns content_type='blueprint' for course structures
   - can_parse: True if valid JSON with recognized structure keys

3. **MarkdownParser** (`markdown_parser.py`):
   - Parses Markdown content into structured sections
   - Uses regex to detect headers (# ## ###), lists, code blocks, emphasis
   - Converts to structured reading/video_script format
   - Preserves original Markdown in metadata for reference
   - can_parse: True if contains Markdown syntax (headers, lists, emphasis)

4. **CSVParser** (`csv_parser.py`):
   - Parses CSV into quiz questions
   - Expected columns: question, option_a, option_b, option_c, option_d, correct, feedback (optional)
   - Returns content_type='quiz' with questions list
   - Validates answer distribution (correct column values)
   - can_parse: True if valid CSV with required columns

5. **ZIPParser** (`zip_parser.py`):
   - Parses generic ZIP archives (not SCORM - that's handled by SCORMParser in Plan 12-02)
   - Lists all files in the archive with paths and sizes
   - Extracts text/markdown/JSON content from files within the archive
   - Detects archive structure (flat vs nested folders)
   - Returns content_type='archive' with files list and extracted content
   - can_parse: True if valid ZIP without imsmanifest.xml (SCORM indicator)
   - Delegates to other parsers for individual file content extraction

6. Update `__init__.py` to export all parsers including ZIPParser

7. Create comprehensive tests in `tests/test_import_parsers.py`:
   - Test each parser's can_parse detection
   - Test successful parsing of valid content
   - Test ParseResult structure and metadata
   - Test warning generation for edge cases
   - Test provenance tracking
   - Test ZIPParser file listing and content extraction
   - Test ZIPParser delegates to correct parser for each file type
  </action>
  <verify>
    pytest tests/test_import_parsers.py -v
  </verify>
  <done>
    All 5 parsers pass tests for format detection, content parsing, and metadata extraction
  </done>
</task>

</tasks>

<verification>
- All parsers importable from src.import.parsers
- Each parser correctly detects its format via can_parse()
- ParseResult contains content, metadata, warnings, and provenance
- ZIPParser extracts files and delegates parsing to appropriate parsers
- Tests cover happy path and edge cases for each format
</verification>

<success_criteria>
- BaseParser ABC defines consistent interface
- TextParser extracts structure from plain text
- JSONParser validates and maps blueprint JSON
- MarkdownParser converts Markdown to structured format
- CSVParser imports quiz questions with validation
- ZIPParser lists and extracts archive contents
- All tests pass (target: 20+ tests)
</success_criteria>

<output>
After completion, create `.planning/phases/12-ai-interactive-features/12-01-SUMMARY.md`
</output>
