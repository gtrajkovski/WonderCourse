---
phase: 07-validation-quality
plan: 03
type: tdd
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/validators/blooms_validator.py
  - tests/test_blooms_validator.py
autonomous: true

must_haves:
  truths:
    - "System validates Bloom's taxonomy distribution across activities"
    - "Error if fewer than 2 different Bloom's levels used"
    - "Warning if more than 80% of activities use single level"
    - "Suggestion if no higher-order thinking levels (Analyze/Evaluate/Create)"
  artifacts:
    - path: "src/validators/blooms_validator.py"
      provides: "BloomsValidator class"
      exports: ["BloomsValidator"]
    - path: "tests/test_blooms_validator.py"
      provides: "BloomsValidator tests"
      min_lines: 60
  key_links:
    - from: "src/validators/blooms_validator.py"
      to: "src/validators/validation_result.py"
      via: "import"
      pattern: "from src.validators.validation_result import ValidationResult"
---

<objective>
Create BloomsValidator to check Bloom's taxonomy level distribution across course activities.

Purpose: Implements QA-05 (validates Bloom's taxonomy level distribution). Courses should have cognitive diversity, not all activities at the same level. Warns about imbalanced distributions and suggests adding higher-order thinking activities.

Output: BloomsValidator class with validate() method that returns ValidationResult with distribution analysis.
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-validation-quality/07-RESEARCH.md
@.planning/phases/07-validation-quality/07-01-PLAN.md
@src/validators/validation_result.py
@src/core/models.py
</context>

<feature>
  <name>BloomsValidator for taxonomy distribution</name>
  <files>src/validators/blooms_validator.py, tests/test_blooms_validator.py</files>
  <behavior>
    BloomsValidator.validate(course) returns ValidationResult with:

    Cases:
    - Course with no activities -> is_valid=True, suggestion "Add activities to analyze"
    - Activities with no bloom_level set -> counted as having no Bloom's data
    - Only 1 unique Bloom's level -> error "Only 1 Bloom's level used (minimum 2)"
    - All 6 activities with same level -> warning "80%+ single level imbalanced"
    - No higher-order levels (ANALYZE, EVALUATE, CREATE) -> suggestion "Consider adding..."
    - 3+ unique levels with balance -> no errors, no warnings

    Metrics:
    - unique_levels: int (count of distinct Bloom's levels)
    - total_activities: int (activities with bloom_level set)
    - distribution: dict mapping level name to percentage
    - dominant_level: str (most common level)
  </behavior>
  <implementation>
Create BloomsValidator class:

```python
from collections import Counter
from src.validators.validation_result import ValidationResult
from src.core.models import Course, BloomLevel

class BloomsValidator:
    """Validates Bloom's taxonomy level distribution."""

    MIN_DIVERSITY = 2  # At least 2 different levels
    IMBALANCE_THRESHOLD = 0.80  # Warn if >80% single level

    HIGHER_ORDER_LEVELS = [BloomLevel.ANALYZE, BloomLevel.EVALUATE, BloomLevel.CREATE]

    def validate(self, course: Course) -> ValidationResult:
        """Run Bloom's distribution validation."""
        errors = []
        warnings = []
        suggestions = []

        # Get all activities with bloom_level set
        all_activities = self._flatten_activities(course)
        bloom_activities = [a for a in all_activities if a.bloom_level is not None]

        if not bloom_activities:
            return ValidationResult(
                is_valid=True,
                errors=[],
                warnings=[],
                suggestions=["Add activities with Bloom's levels to analyze distribution"],
                metrics={
                    "unique_levels": 0,
                    "total_activities": 0,
                    "distribution": {},
                    "dominant_level": None
                }
            )

        # Count levels
        level_counts = Counter(a.bloom_level for a in bloom_activities)
        unique_levels = len(level_counts)
        total = len(bloom_activities)

        # ERROR: Must have at least 2 different levels
        if unique_levels < self.MIN_DIVERSITY:
            errors.append(
                f"Only {unique_levels} Bloom's level(s) used (minimum {self.MIN_DIVERSITY} for diverse learning)"
            )

        # WARNING: Imbalanced distribution (>80% single level)
        max_count = max(level_counts.values())
        if max_count / total > self.IMBALANCE_THRESHOLD:
            dominant_level = max(level_counts, key=level_counts.get)
            warnings.append(
                f"Bloom's distribution imbalanced: {max_count/total:.0%} {dominant_level.value} (consider more variety)"
            )

        # SUGGESTION: No higher-order thinking
        has_higher_order = any(level in self.HIGHER_ORDER_LEVELS for level in level_counts.keys())
        if not has_higher_order:
            suggestions.append(
                "Consider adding higher-order thinking activities (Analyze, Evaluate, Create)"
            )

        # Build metrics
        distribution = {level.value: round(count / total, 2) for level, count in level_counts.items()}
        dominant_level = max(level_counts, key=level_counts.get)

        metrics = {
            "unique_levels": unique_levels,
            "total_activities": total,
            "distribution": distribution,
            "dominant_level": dominant_level.value
        }

        return ValidationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings,
            suggestions=suggestions,
            metrics=metrics
        )

    def _flatten_activities(self, course: Course):
        """Extract all activities from course structure."""
        activities = []
        for module in course.modules:
            for lesson in module.lessons:
                activities.extend(lesson.activities)
        return activities
```
  </implementation>
</feature>

<verification>
RED phase:
- Write tests first that fail
- Run pytest tests/test_blooms_validator.py - tests must FAIL

GREEN phase:
- Implement BloomsValidator
- Run pytest tests/test_blooms_validator.py - tests must PASS

REFACTOR phase (if needed):
- Clean up implementation
- Run pytest tests/test_blooms_validator.py - tests still PASS
</verification>

<success_criteria>
- BloomsValidator.validate() returns ValidationResult
- Single Bloom's level produces error
- 80%+ single level produces warning
- No higher-order levels produces suggestion
- Activities without bloom_level are excluded from analysis
- Metrics include distribution percentages
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-validation-quality/07-03-SUMMARY.md`
</output>
