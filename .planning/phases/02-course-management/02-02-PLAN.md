---
phase: 02-course-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/__init__.py
  - src/api/modules.py
  - tests/test_modules_api.py
autonomous: true

must_haves:
  truths:
    - "User can add a module to a course"
    - "User can remove a module from a course"
    - "User can update a module's title and description"
    - "User can reorder modules within a course"
    - "Deleting a module cleans up learning outcome mappings referencing its activities"
  artifacts:
    - path: "src/api/__init__.py"
      provides: "API package init"
    - path: "src/api/modules.py"
      provides: "Module CRUD endpoints as Flask Blueprint"
      exports: ["modules_bp"]
    - path: "tests/test_modules_api.py"
      provides: "Module API endpoint tests"
      contains: "def test_"
  key_links:
    - from: "src/api/modules.py"
      to: "src/core/project_store.py"
      via: "ProjectStore load/save for atomic updates"
      pattern: "project_store\\.load"
    - from: "app.py"
      to: "src/api/modules.py"
      via: "Blueprint registration"
      pattern: "register_blueprint"
---

<objective>
Create module CRUD API endpoints (add, update, delete, reorder) using Flask Blueprint pattern. Establish the Blueprint registration pattern in app.py that all subsequent API plans will follow.

Purpose: COURSE-07 requires module management. This plan also establishes the Blueprint pattern for lesson, activity, and outcome endpoints.
Output: Module API Blueprint with full CRUD + reorder, registered in app.py, with tests.
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-course-management/02-RESEARCH.md
@src/core/models.py
@src/core/project_store.py
@app.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create module API Blueprint with CRUD and reorder endpoints</name>
  <files>src/api/__init__.py, src/api/modules.py</files>
  <action>
Create `src/api/__init__.py` (empty or with brief docstring).

Create `src/api/modules.py` with a Flask Blueprint `modules_bp`:

Endpoints (all under /api/courses/<course_id>/modules):

1. `GET /api/courses/<course_id>/modules` — List all modules for a course. Returns JSON array of module dicts sorted by `order`.

2. `POST /api/courses/<course_id>/modules` — Create a new module. Request body: `{"title": str, "description": str (optional)}`. Auto-assigns `order` as len(course.modules). Returns 201 with module dict.

3. `PUT /api/courses/<course_id>/modules/<module_id>` — Update module title/description. Request body: `{"title": str, "description": str}`. Returns updated module dict.

4. `DELETE /api/courses/<course_id>/modules/<module_id>` — Delete module. Collects all activity IDs from module's lessons, removes them from all learning outcome mapped_activity_ids. Removes module from course.modules. Renumbers remaining modules (mod.order = i). Returns 200 with success message.

5. `PUT /api/courses/<course_id>/modules/reorder` — Reorder modules. Request body: `{"old_index": int, "new_index": int}`. Validates indices. Pops module at old_index, inserts at new_index. Renumbers all modules. Returns 200 with updated modules list.

All endpoints follow atomic pattern:
- Load course via project_store.load(course_id) -> 404 if None
- Modify in memory
- Save once via project_store.save(course)
- Return JSON response

The Blueprint needs access to project_store. Use a module-level variable that gets set during blueprint registration. In modules.py:
```python
from flask import Blueprint, request, jsonify
from src.core.models import Module

modules_bp = Blueprint('modules', __name__)
_project_store = None

def init_modules_bp(project_store):
    global _project_store
    _project_store = project_store
```

Error handling: ValueError -> 400, not found -> 404, Exception -> 500.
  </action>
  <verify>Verify file exists and has all 5 endpoint functions: `py -3 -c "from src.api.modules import modules_bp; print('OK')"`</verify>
  <done>Module Blueprint has GET list, POST create, PUT update, DELETE remove, PUT reorder endpoints with atomic save pattern and cascading cleanup.</done>
</task>

<task type="auto">
  <name>Task 2: Register Blueprint in app.py and add tests</name>
  <files>app.py, tests/test_modules_api.py</files>
  <action>
1. In app.py, after the AIClient initialization block, register the modules blueprint:
```python
from src.api.modules import modules_bp, init_modules_bp
init_modules_bp(project_store)
app.register_blueprint(modules_bp)
```

2. Create tests/test_modules_api.py with a `client` fixture (reuse pattern from conftest.py but also init the blueprint store). Tests:

- test_create_module: POST to create module, verify 201, verify module has id/title/order
- test_create_module_course_not_found: POST to invalid course, verify 404
- test_list_modules: Create 2 modules, GET list, verify order and count
- test_update_module: Create module, PUT update title, verify new title
- test_update_module_not_found: PUT to invalid module_id, verify 404
- test_delete_module: Create module, DELETE, verify 200, verify GET list is empty
- test_delete_module_cleans_outcome_mappings: Create course with module containing activity, add learning outcome with mapped_activity_ids referencing that activity, delete module, verify outcome's mapped_activity_ids is cleaned
- test_reorder_modules: Create 3 modules (A, B, C), reorder to move A to position 2 (B, C, A), verify new order values
- test_reorder_modules_invalid_index: Reorder with out-of-bounds index, verify 400

The test fixture needs to create a course first (via POST /api/courses), then use its ID for module operations. Alternatively, create course directly via project_store and use its ID.

Important: The test fixture must also call init_modules_bp with the temp project_store:
```python
@pytest.fixture
def client(tmp_path, monkeypatch):
    projects_dir = tmp_path / "projects"
    projects_dir.mkdir(parents=True, exist_ok=True)

    import app as app_module
    from src.api.modules import init_modules_bp
    temp_store = ProjectStore(projects_dir)
    app_module.project_store = temp_store
    init_modules_bp(temp_store)

    app_module.app.config['TESTING'] = True
    return app_module.app.test_client()
```
  </action>
  <verify>Run `py -3 -m pytest tests/test_modules_api.py -v` — all 9 tests pass</verify>
  <done>Module Blueprint registered in app.py. 9+ tests covering CRUD, reorder, cascade cleanup, and error cases all pass.</done>
</task>

</tasks>

<verification>
```bash
py -3 -m pytest tests/test_modules_api.py tests/test_app.py -v
```
All module API tests pass. Existing app tests still pass (no regressions).
</verification>

<success_criteria>
- POST /api/courses/<id>/modules creates module with auto-order
- PUT /api/courses/<id>/modules/<mid> updates module metadata
- DELETE /api/courses/<id>/modules/<mid> removes module and cleans outcome mappings
- PUT /api/courses/<id>/modules/reorder moves module and renumbers all
- Blueprint pattern established for subsequent plans
- 9+ tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-course-management/02-02-SUMMARY.md`
</output>
