---
phase: 02-course-management
plan: 04
type: execute
wave: 2
depends_on: ["02-02"]
files_modified:
  - src/api/learning_outcomes.py
  - tests/test_learning_outcomes_api.py
autonomous: true

must_haves:
  truths:
    - "User can add a learning outcome to a course with ABCD components and Bloom's level"
    - "User can edit a learning outcome's audience, behavior, condition, degree, bloom_level, and tags"
    - "User can delete a learning outcome from a course"
    - "User can list all learning outcomes for a course"
  artifacts:
    - path: "src/api/learning_outcomes.py"
      provides: "Learning outcome CRUD endpoints as Flask Blueprint"
      exports: ["learning_outcomes_bp"]
    - path: "tests/test_learning_outcomes_api.py"
      provides: "Learning outcome API endpoint tests"
      contains: "def test_"
  key_links:
    - from: "src/api/learning_outcomes.py"
      to: "src/core/models.py"
      via: "LearningOutcome constructor with BloomLevel enum"
      pattern: "LearningOutcome"
    - from: "app.py"
      to: "src/api/learning_outcomes.py"
      via: "Blueprint registration"
      pattern: "register_blueprint"
---

<objective>
Create learning outcome CRUD API endpoints for defining outcomes with Bloom's taxonomy levels, ABCD components, and tags. This is CRUD only — outcome-to-activity mapping is handled in Plan 02-05.

Purpose: COURSE-06 requires defining learning outcomes with Bloom's taxonomy levels and tags.
Output: Learning outcome API Blueprint with full CRUD, registered in app.py, with tests.
</objective>

<execution_context>
@C:\Users\gpt30\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gpt30\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-course-management/02-02-SUMMARY.md
@src/core/models.py
@src/api/modules.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create learning outcome API Blueprint with CRUD endpoints</name>
  <files>src/api/learning_outcomes.py, app.py</files>
  <action>
Create `src/api/learning_outcomes.py` with Blueprint `learning_outcomes_bp` following the init pattern from modules.py.

Endpoints (all under /api/courses/<course_id>/outcomes):

1. `GET /api/courses/<course_id>/outcomes` — List all learning outcomes for a course. Returns JSON array of outcome dicts.

2. `POST /api/courses/<course_id>/outcomes` — Create learning outcome. Request body:
   ```json
   {
     "audience": "Learners",
     "behavior": "implement a REST API",
     "condition": "Given Flask documentation",
     "degree": "with proper error handling",
     "bloom_level": "apply",
     "tags": ["flask", "api"]
   }
   ```
   All fields optional with sensible defaults (empty strings, BloomLevel.APPLY, empty tags).
   Returns 201 with outcome dict including generated ID.

3. `PUT /api/courses/<course_id>/outcomes/<outcome_id>` — Update learning outcome. Body can include any combination of: audience, behavior, condition, degree, bloom_level (string enum value), tags (list of strings). Returns updated outcome dict.

4. `DELETE /api/courses/<course_id>/outcomes/<outcome_id>` — Delete learning outcome. Remove from course.learning_outcomes list. Returns 200 with success message.

For bloom_level enum handling in POST and PUT:
```python
if 'bloom_level' in data:
    try:
        bloom_level = BloomLevel(data['bloom_level'])
    except ValueError:
        return jsonify({"error": f"Invalid bloom_level: {data['bloom_level']}. Valid values: {[b.value for b in BloomLevel]}"}), 400
```

Register in app.py alongside other blueprints.
  </action>
  <verify>Verify import: `py -3 -c "from src.api.learning_outcomes import learning_outcomes_bp; print('OK')"`</verify>
  <done>Learning outcome Blueprint has list, create, update, delete endpoints. Bloom's level validated as enum. Blueprint registered in app.py.</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for learning outcome API endpoints</name>
  <files>tests/test_learning_outcomes_api.py</files>
  <action>
Create tests/test_learning_outcomes_api.py with fixture pattern matching test_modules_api.py (temp store, init all blueprints).

Tests:

1. test_create_outcome: POST with full ABCD + bloom_level + tags, verify 201, verify all fields in response
2. test_create_outcome_minimal: POST with just behavior field, verify defaults applied (bloom_level=apply, empty tags)
3. test_create_outcome_invalid_bloom: POST with bloom_level="invalid", verify 400 with helpful error message listing valid values
4. test_list_outcomes: Create 2 outcomes, GET list, verify count=2
5. test_update_outcome: Create outcome, PUT update behavior and bloom_level, verify changes persisted
6. test_update_outcome_tags: Create outcome, PUT update tags to ["python", "flask", "api"], verify tags updated
7. test_delete_outcome: Create outcome, DELETE, verify 200, verify list is empty
8. test_delete_outcome_not_found: DELETE with invalid outcome_id, verify 404
9. test_outcome_bloom_levels: Create outcomes with each BloomLevel value (remember, understand, apply, analyze, evaluate, create), verify all accepted

Each test should create a course first, then operate on outcomes within that course.
  </action>
  <verify>Run `py -3 -m pytest tests/test_learning_outcomes_api.py -v` — all 9 tests pass</verify>
  <done>9 tests covering CRUD, validation, Bloom's levels, tags, and error cases all pass.</done>
</task>

</tasks>

<verification>
```bash
py -3 -m pytest tests/test_learning_outcomes_api.py tests/test_app.py -v
```
All outcome tests pass. Existing app tests still pass.
</verification>

<success_criteria>
- POST /api/courses/<id>/outcomes creates outcome with ABCD components and Bloom's level
- PUT /api/courses/<id>/outcomes/<oid> updates any outcome field
- DELETE /api/courses/<id>/outcomes/<oid> removes outcome
- Invalid bloom_level returns 400 with valid values listed
- All 6 BloomLevel enum values accepted
- 9+ tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-course-management/02-04-SUMMARY.md`
</output>
